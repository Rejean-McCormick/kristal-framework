===== TOC (42 files) =====
0001  00-overview/v2-to-v3-summary.md
0002  00-overview/vision-and-scope.md
0003  01-core-spec/ids-canonicalization-hashing.md
0004  01-core-spec/kristal-v3-core-spec.md
0005  01-core-spec/signatures-trust.md
0006  02-schemas/claim-ir.schema.json
0007  02-schemas/exchange-manifest.schema.json
0008  02-schemas/resolved-claim-ir.schema.json
0009  02-schemas/runtime-pack-manifest.schema.json
0010  02-schemas/validation-report.schema.json
0011  03-reproducibility/allowed-runtime-pack-policies.md
0012  03-reproducibility/deterministic-build-rules.md
0013  03-reproducibility/reproducibility-acceptance-tests.md
0014  04-query/query-contract.md
0015  05-profiles/profile-jsonld-export.md
0016  05-profiles/profile-provenance-nanopub-provo.md
0017  05-profiles/profile-query-tpf-pagination.md
0018  05-profiles/profile-rdf-integrity-rdfc.md
0019  05-profiles/profile-rdf-wdqs-export.md
0020  05-profiles/profile-validation-shacl.md
0021  05-profiles/profile-validation-shex.md
0022  06-integration/architect-rendering-contract.md
0023  06-integration/konnaxion-distribution-contract.md
0024  06-integration/orgo-workflow-contract.md
0025  06-integration/sentient-resolution-contract.md
0026  07-security/downgrade-rollback-policy.md
0027  07-security/key-management-and-trust-roots.md
0028  07-security/multi-tenancy-boundaries.md
0029  08-ops/failure-paths-and-resilience.md
0030  08-ops/logging-and-correlation-ids.md
0031  08-ops/operational-guidance-template.md
0032  08-ops/release-strategies.md
0033  09-test-vectors/jcs/expected-hashes.txt
0034  09-test-vectors/jcs/README.md
0035  09-test-vectors/jcs/vectors.json
0036  09-test-vectors/rdfc/README.md
0037  10-examples/claim-ir.example.json
0038  10-examples/exchange.example.json
0039  10-examples/resolved-claim-ir.example.json
0040  10-examples/runtime-pack-manifest.example.json
0041  10-examples/validation-report.example.json
0042  README.md
===== END TOC =====


===== BEGIN 00-overview/v2-to-v3-summary.md (#0001) =====
# 00-overview/v2-to-v3-summary.md

## Status

Draft

## Date

2026-01-07 

## Purpose

Summarize the changes from Kristal v2 (draft) to Kristal v3, with emphasis on interoperability, determinism, and reproducible offline execution.

---

## What v3 is trying to achieve

v3 tightens the v2 draft into a more **interoperable** and **reproducible** standard, incorporating literature-driven improvements around Parquet-based RDF storage, Roaring+Run, binary-fuse filters, nanopublications/PROV-O, RDFC test gating, and high-throughput JSON ingestion patterns. 

### Key outcomes in v3

* **Normative canonicalization + hashing** that is portable across languages, with JSON-first identity and optional RDF-level hashing. 
* **Stronger RDF/JSON-LD interoperability**: stable JSON-LD 1.1 context/profile plus WDQS-compatible RDF export. 
* **Runtime Pack reproducibility**: fully specified membership-filter metadata, bitmap conventions, and Parquet ordering/row-group policy. 
* **More ergonomic offline query surface**: TPF-like pagination plus per-pattern cardinality metadata. 
* **First-class subset recipes + compiler build metadata** so offline subsets become reproducible artifacts. 
* **Portable provenance packaging** via an optional nanopublication/PROV-O shaped mode for Exchange exports. 

---

## Summary of major deltas (v2 → v3)

### 1) Canonicalization, identity, and integrity become portable and testable

* `canonical_json` becomes normatively **RFC 8785 (JCS)** to eliminate JSON ambiguity. 
* Signing/verification workflow is standardized (remove signatures → canonicalize → hash/verify), with explicit **fail-closed** failure modes. 
* Optional export integrity: **RDF Dataset Canonicalization (RDFC-1.0)** and an `rdf_hash` computed from canonical N-Quads. 
* CI gating: run selected RDFC tests and publish golden vectors; enforce resource limits for worst-case datasets. 

### 2) Export interoperability is formalized

* Define deterministic JSON-LD 1.1 profile and WDQS-compatible RDF export profile. 
* Optional “nanopub mode” export for Exchange with head graph linking assertion + provenance + publication info graphs; use PROV-O terms for portable attribution chains. 

### 3) Runtime Pack reproducibility and performance are specified (not implied)

* Parquet triples table: treat ordering as an index; record sort order(s) and row-group sizing policy (controls BRI effectiveness). 
* Optional Parquet-level Bloom filters to prune row groups during scans. 
* Membership filters: make **binary-fuse** the recommended default; standardize parameters (variant, seeds, bits/key) and record them; explicitly define what the filter gates and how false positives are pruned deterministically. 
* Roaring bitmaps: require run optimization (Roaring+Run) where beneficial; optionally record container statistics. 

### 4) Offline query surface gets a predictable “integration mode”

* Add TPF-like pagination for triple-pattern results and per-pattern cardinality (exact/approx) for tooling predictability. 
* Add optional compiled “truthy/best-rank” projection so offline defaults can match WDQS `wdt:` semantics. 
* Define portability profile for join1 caps (default cap + strict mode) to reduce cross-implementation divergence. 

### 5) Subset builder + compiler throughput become first-class

* “Subset recipes” become explicit: seeds, deterministic expansion rules, allow/deny lists, depth limits, stopping criteria, snapshot identifiers. 
* Compilers must support field-skipping / on-demand parsing for Exchange JSON/JSON-LD; recommend two-stage parsing; record build metrics (size, wall time, peak memory). 

---

## Compatibility and migration notes (v2 → v3)

* Canonical JSON becomes normatively **RFC 8785 (JCS)**; v2 canonicalization is acceptable only if JCS-compatible. 
* New fields (e.g., `rdf_hash`, `canonicalization_profile`, SHACL report pointers, membership-filter build metadata, Parquet ordering policy) are additive. 
* Runtime Pack readers should ignore unknown fields by default, **but must fail closed** on declared hashes/signatures that don’t verify. 
* Nanopub/PROV-O mode remains optional; packs without it remain valid. 

---

## Roadmap (summary)

* **P0: Spec deltas** — v3 spec updates: canonicalization, exports, runtime metadata, nanopub mode, Parquet ordering. 
* **P1: Reference tooling** — compiler updates + validators + export tooling; reproducible builds; SHACL/ShEx hooks; WDQS export profile; Parquet ordering support. 
* **P2: Test corpus** — golden files: JCS hashes, RDF hashes, RDFC tests, export fixtures, query fixtures; include adversarial canonicalization cases. 
* **P3: Migration & docs** — v2→v3 migration guide + conformance checklist; compatibility matrix. 

---

## Where this summary fits in the doc set

This overview is the “why/what changed” page. For details, see:

* `01-core-spec/` for normative identity + integrity rules
* `03-reproducibility/` for allowed policy sets and determinism requirements
* `05-profiles/` for optional RDFC / nanopub+PROV-O / SHACL+ShEx / TPF query modes
* `09-test-vectors/` for golden vectors and CI gating guidance

===== END 00-overview/v2-to-v3-summary.md (#0001) =====

===== BEGIN 00-overview/vision-and-scope.md (#0002) =====
# Vision and scope (Kristal v3)

Kristal is the portable, verifiable, offline-executable unit of encyclopedic knowledge in the ecosystem. A Kristal is **not a document** and not free text. It is a **compiled knowledge artifact** designed to be **Wikidata/Wikibase-aligned**, **traceable**, **AI-ready**, and **executable offline**.

Kristal v3 tightens interoperability and reproducibility by making canonicalization + hashing unambiguous, defining strict pipeline contracts, and requiring deterministic build manifests—while keeping the normative core small and expressing advanced capabilities as explicit profiles.

## Goals

Kristal v3 aims to:

1. **Interoperable identity**
   - Identical content yields identical IDs across languages and toolchains.
   - Hashing and signature verification behavior is fully specified.

2. **Deterministic compilation**
   - Exchange and Runtime Pack generation is reproducible.
   - Build-affecting policies and parameters are recorded in manifests.

3. **Strict pipeline boundaries**
   - Extractors produce **Claim-IR only** (schema-constrained proposals with uncertainty and evidence).
   - SenTient performs resolution without forced disambiguation.
   - Validation is a deterministic acceptance gate (“no compile on fail”).
   - Architect renders deterministic outputs after validation and cannot introduce new facts.

4. **Offline execution**
   - Runtime Packs are executable offline and do not depend on SPARQL endpoints, network access, or LLMs.
   - Query semantics are intentionally constrained to remain predictable and portable.

5. **Standards-aligned exports**
   - Define stable export profiles (JSON-LD and RDF/WDQS-aligned projections).
   - Provide optional integrity and provenance packaging profiles for high-assurance contexts.

## Non-goals

Kristal v3 does **not** attempt to:

- Provide full SPARQL semantics in Runtime Packs.
- Encode operational/deployment patterns as first-class objects inside Exchange or Runtime Pack schemas.
- Guarantee identical performance across implementations (only identical outputs for deterministic modes).
- Replace Orgo’s operational logging/auditing system (Kristal records knowledge and build metadata; Orgo records workflow and governance).

## Core model and artifacts

Kristal exists as: **standard + compilation pipeline + runtime pack**.

### Core artifacts (release outputs)
Each Kristal release produces two primary artifacts:

1. **Kristal Exchange**
   - Canonical, content-addressed, auditable source of truth for validated knowledge.
   - Designed to be mergeable and comparable across toolchains.

2. **Kristal Runtime Pack**
   - Derived, offline-executable indexed form for constrained queries.
   - Optimized for offline distribution and predictable execution.

### Pipeline stages (conceptual)
1. **Ingest**: documents/web/PDF/datasets/signals
2. **Claim-IR**: extractor outputs schema-constrained proposals (uncertainty + evidence)
3. **Resolution (SenTient)**: surfaces → ranked QIDs/PIDs; normalize values; preserve unresolved ambiguity
4. **Validation**: deterministic acceptance gate; if validation fails, compilation MUST stop
5. **Exchange finalize**: canonical + signed + content-addressed
6. **Runtime Pack compile**: deterministic, manifest-recorded policies
7. **Render (Architect)**: deterministic generation after validation; must trace to claims/evidence

## Normative core vs profiles

Kristal v3 is structured as:
- **Core (normative, required):** minimal determinism surface area with strong defaults
- **Profiles (optional, standardized):** advanced features (integrity, provenance, richer exports, pagination)

### v3 Core includes (high level)
- RFC 8785 (JCS) canonicalization for hashed JSON objects
- Explicit hashing material and exclusions (e.g., signatures excluded from hashed payload)
- Fail-closed verification when declared hashes/signatures do not verify
- Deterministic build requirements and reproducible manifests
- Core schemas and core test vectors

### Profiles include (examples)
- JSON-LD export profile
- RDF/WDQS-aligned export profile
- RDF Integrity profile (RDFC + resource limits + CI gating)
- Provenance packaging profile (nanopub + PROV-O)
- Validation profiles (SHACL, ShEx)
- Query pagination profile (TPF-like semantics)

## Ecosystem integration placement (Orgo × SenTient × Architect × Konnaxion)

- **Orgo**: operational control plane for Kristal workflows (ingest → resolve → validate → publish), including audits and distribution status.
- **SenTient**: resolver/reconciler implementing the resolution contract.
- **Architect**: deterministic renderer consuming validated claims/query results, producing traceable outputs without adding facts.
- **Konnaxion**: distribution and offline UX layer for Runtime Packs (verification, caching, versioning, rollback/downgrade rules).

Operational patterns (circuit breakers, DLQs, CQRS framing, canary/blue-green rollout, structured logs + correlation IDs) are used as **non-normative guidance** for the build/distribution system and are not embedded into Kristal artifact schemas.

## Document map

- Overview and deltas: `00-overview/`
- Normative core: `01-core-spec/`
- Schemas: `02-schemas/`
- Reproducibility: `03-reproducibility/`
- Query: `04-query/`
- Profiles: `05-profiles/`
- Integration contracts: `06-integration/`
- Security and tenancy: `07-security/`
- Operational guidance (non-normative): `08-ops/`
- Test vectors: `09-test-vectors/`
- Examples: `10-examples/`

===== END 00-overview/vision-and-scope.md (#0002) =====

===== BEGIN 01-core-spec/ids-canonicalization-hashing.md (#0003) =====
# 01-core-spec/ids-canonicalization-hashing.md

## Status

Draft (v3)

## Purpose

This document specifies the **normative** rules for:

* `canonical_json` (how Exchange objects are canonicalized)
* `kristal_id` (how content-addressed IDs are computed)
* optional `statement_id` (how statement-level IDs are computed)
* optional `rdf_hash` (RDF-level hash for deterministic exports)

v3’s goal is that two independent implementations produce identical IDs for identical artifacts, using a portable canonicalization and hashing pipeline.  

---

## 1. Terminology

* **Exchange**: the canonical Kristal Exchange JSON artifact.
* **Runtime Pack**: the derived offline-executable artifact (not defined here).
* **canonical_json**: the canonical byte representation of an object after applying this spec’s canonicalization rules.
* **Hash target**: the exact JSON object that is canonicalized and hashed to produce an ID.
* **JCS**: JSON Canonicalization Scheme, RFC 8785, used as the normative canonicalization method in v3. 

Normative keywords: MUST, MUST NOT, SHOULD, SHOULD NOT, MAY.

---

## 2. Normative canonical_json (v3)

### 2.1 Canonicalization method (mandatory)

`canonical_json` MUST be produced using **RFC 8785 (JCS)**. 

### 2.2 Canonicalization profile recording (mandatory)

Every Exchange artifact and every Runtime Pack manifest MUST record:

* `canonicalization_profile` (string identifier)
* `canonicalization_version` (string or integer)

This is required so hashes remain comparable across toolchains. 

**Default profile identifier (recommended):**

* `canonicalization_profile = "kristal.v3:jcs-rfc8785"`
* `canonicalization_version = "1"`

Implementations MAY introduce additional profiles, but MUST make them explicit and MUST NOT claim v3 core conformance under an unspecified profile.

---

## 3. Hash target selection

### 3.1 Hash exclusions (mandatory)

To compute IDs, implementations MUST derive a **hash target object** from the Exchange artifact by removing:

1. `kristal_id` (the output field)
2. any declared signatures / attestations fields (wherever they appear)

This aligns with v0.1/v2 guidance to hash “exchange_without_signatures” while keeping signatures as optional overlays.   

**Note:** This doc defines *what is removed* to avoid circular hashing and to make signing/verifying well-defined.

### 3.2 Optional “stable content vs build metadata” guidance (non-normative)

v3 encourages reproducibility and comparable IDs across independent builds.  If you include volatile metadata (wall-clock timestamps, transient metrics) in the hashed region, the `kristal_id` will change even when knowledge content does not.

Recommendation:

* keep volatile compilation telemetry in a clearly separated section (e.g., `manifest.build`) and (if you choose) exclude it **only via a declared profile** (do not do silent exclusions).

---

## 4. kristal_id computation (mandatory)

### 4.1 Definition

Kristal Exchange uses content-addressing:

`kristal_id = sha256(canonical_json(exchange_without_signatures))`  

In v3, the phrase “exchange_without_signatures” is formalized as the **hash target** in Section 3.

### 4.2 Algorithm (normative)

Given an Exchange JSON object `E`:

1. Produce `T = hash_target(E)` by:

   * removing `kristal_id`
   * removing signatures/attestations fields (per Section 3.1)
2. Serialize `T` to bytes `B = JCS(T)` using RFC 8785. 
3. Compute `H = SHA-256(B)`.
4. Encode `H` as **lowercase hex**.
5. Set:

   * `kristal_id = "sha256:" + hex(H)`

### 4.3 Acceptance criteria (mandatory)

* Two independent implementations MUST produce identical `kristal_id` for the same Exchange artifact under the same `canonicalization_profile` and `canonicalization_version`. 

---

## 5. statement_id computation (optional but recommended)

Kristal v0.1 already supports optional statement identifiers:
`statement_id = hash(subject + property + value + qualifiers + reference_ids)` 

### 5.1 Purpose

A stable `statement_id` enables: deduplication, merge operations, and fine-grained provenance tracking. 

### 5.2 Normative definition (if enabled)

If `statement_id` is present, the producer MUST compute it deterministically from a **statement hash target** that includes:

* `subject` (QID)
* `property` (PID)
* `value` (fully normalized literal or QID)
* `qualifiers` (including all qualifier snaks)
* `reference pointers` (e.g., `evidence_id` or normalized reference snaks)

Procedure (recommended):

1. Build statement hash target object `S`.
2. Canonicalize with the same `canonicalization_profile` as the Exchange. 
3. Hash with SHA-256.
4. Encode as `sha256:<hex>`.

### 5.3 Ordering rules (normative when relevant)

Where statement substructures are semantically sets (qualifiers, references), implementations MUST sort them deterministically before hashing the statement to avoid ID drift. This aligns with earlier v0.1 canonicalization intent (sorting where order is not semantically meaningful). 

---

## 6. Optional RDF-level hashing: rdf_hash (profile)

v3 adds an optional RDF integrity mode for exports:

* `rdf_hash` computed using **RDF Dataset Canonicalization (RDFC-1.0)** from canonical N-Quads. 

This is **optional** and enabled only under an explicit profile (see `05-profiles/profile-rdf-integrity-rdfc.md` in the doc plan). When enabled, CI gating against the RDFC test suite is expected, with resource limits. 

---

## 7. Optional human-verifiable ID representations (profile)

v3 allows an optional Trusty/ni-URI-style representation as a human-usable, verifiable form of `kristal_id` (or `rdf_hash` in RDF mode). 

Nanopublication guidance similarly treats Trusty-URI-like commitments as integrity keys. 

---

## 8. Signing workflow dependency (normative reference)

The signing/verification workflow is:

**remove signatures → canonicalize → hash/verify → sign** 

Fail-closed semantics for declared hashes/signatures are specified in `01-core-spec/signatures-trust.md`. (This file defines the ID and canonicalization prerequisites that signing depends on.)

===== END 01-core-spec/ids-canonicalization-hashing.md (#0003) =====

===== BEGIN 01-core-spec/kristal-v3-core-spec.md (#0004) =====
# Kristal v3 Core Specification

## Status
Draft (normative core)

## Purpose
Define the **minimal normative requirements** for Kristal v3 conformance, with a strong focus on:
- cross-implementation interoperability,
- deterministic identity and integrity verification,
- reproducible compilation,
- clear inter-system contracts for the Kristal stack.

Everything not explicitly required here is either:
- specified as an **optional standardized profile** (see `05-profiles/`), or
- provided as **non-normative implementation guidance** (see `08-ops/`).

## Scope and non-goals
### In scope
- Canonicalization, hashing, signing, and verification semantics
- Minimal reproducibility requirements and manifest content
- Inter-system contracts: Claim-IR → Resolution → Validation → Exchange → Runtime Pack
- Deterministic baseline exports (JSON-LD / RDF export profiles) sufficient for interoperability

### Out of scope (non-goals)
- Full SPARQL semantics for Runtime Packs
- Operational patterns as schema-level objects (DLQ, circuit breaker, canary, etc.)
- Any specific runtime performance implementation beyond the **portable policy set** (enumerated policies are specified elsewhere)

## Normative language
The key words **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as normative requirements.

## Conformance overview
An implementation is **Kristal v3 Core Conformant** if it:
1. Implements the **canonicalization + identity** rules in this document.
2. Implements **fail-closed integrity verification** semantics.
3. Emits and honors a **minimal reproducibility manifest**.
4. Enforces the **inter-system interface contracts** (schemas + deterministic rules).
5. Produces **deterministic baseline exports** when enabled.

Optional profiles do not affect core conformance unless the implementation claims support for them. If an implementation claims a profile, it MUST satisfy that profile’s requirements.

---

# 1. Artifact model

Kristal v3 defines two primary artifact classes:

1. **Kristal Exchange Artifact (Exchange)**
   - Canonical, auditable, content-addressed source of truth.
   - Mergeable representation of validated knowledge claims.

2. **Kristal Runtime Pack (Runtime Pack)**
   - Derived, indexed, offline-executable representation.
   - Constrained query semantics; NOT full SPARQL.

Both artifact classes MUST have an associated **Manifest**.

---

# 2. Canonicalization and identity (mandatory)

## 2.1 Canonical JSON
- `canonical_json` MUST be defined as **RFC 8785 JSON Canonicalization Scheme (JCS)**.
- Implementations MUST NOT introduce additional canonicalization steps that change byte output beyond JCS.

## 2.2 Content-addressed IDs
### 2.2.1 kristal_id for Exchange
- `kristal_id` MUST be computed as:

`kristal_id = sha256( JCS( exchange_without_signatures ) )`

Where:
- `exchange_without_signatures` is the Exchange artifact with all signature material removed (see Section 3).

### 2.2.2 Runtime Pack identity
- Runtime Packs MUST have a stable `pack_id` or equivalent identifier.
- `pack_id` MUST be content-addressed from the Runtime Pack’s declared reproducibility surface (at minimum: manifest + referenced pack payload hashes, see Section 4).

## 2.3 Canonicalization profile declaration
Artifacts MUST declare:
- `canonicalization_profile` (e.g., `"jcs-rfc8785"`)
- `canonicalization_version` (e.g., `"1.0"`)

This enables cross-toolchain comparison and future evolution.

---

# 3. Integrity and signatures (mandatory)

## 3.1 Signature envelope
If an artifact includes signatures, it MUST do so using a clearly separated signature envelope such that:
- signature fields can be removed deterministically prior to hashing, and
- the hashed content is unambiguous.

## 3.2 Hash/sign workflow (normative)
Signing and verification MUST follow this order:

1. Remove signature material (if present)
2. Canonicalize via JCS
3. Hash (SHA-256)
4. Verify and/or attach signatures

## 3.3 Fail-closed semantics (normative)
If an artifact declares **any** of the following:
- content hash,
- signature,
- signer identity / key reference,

then verifiers MUST:
- **fail closed** if verification fails,
- **fail closed** if declared integrity material is malformed or ambiguous,
- **fail closed** if the declared hash does not match the computed hash.

Unknown non-integrity fields MUST be ignored for forward compatibility, but integrity fields are never “best-effort”.

---

# 4. Minimal reproducibility requirements (mandatory)

Kristal v3 requires reproducibility to be a first-class acceptance criterion.

## 4.1 Minimal reproducibility manifest (required fields)
Every Exchange and Runtime Pack MUST have a manifest containing at minimum:

- `build_id` (unique identifier for the build)
- `build_timestamp` (ISO 8601)
- `compiler` object:
  - `name`
  - `version`
- `config_hash` (hash of the full build configuration)
- `input_snapshots` list (content-addressed references to inputs used)
- `canonicalization_profile` + `canonicalization_version`
- `policy_selections` (portable policy selection identifiers; see `03-reproducibility/allowed-runtime-pack-policies.md`)
- declared hashes for the artifact payload(s)

## 4.2 Rebuild determinism requirement
Given:
- identical input snapshots,
- identical compiler version,
- identical configuration (as defined by `config_hash`),
- identical policy selections,

then:
- Exchange rebuild MUST produce identical `kristal_id`.
- Runtime Pack rebuild MUST produce identical `pack_id` and identical declared payload hashes.

If deterministic output cannot be achieved for some optional optimization, that optimization MUST be moved behind an optional profile or explicitly excluded from the reproducibility surface.

---

# 5. Inter-system interface contracts (mandatory)

Kristal v3 is defined as a pipeline boundary with strict contracts.

## 5.1 Claim-IR contract (proposal boundary)
- Extractors (LLMs, classical systems, hybrids) MUST output **only Claim-IR**.
- Claim-IR MUST be schema-constrained and MUST include:
  - explicit uncertainty representation,
  - explicit evidence pointers,
  - no implicit coercion into resolved entities.

Schema: `02-schemas/claim-ir.schema.json`

## 5.2 Resolution contract (SenTient boundary)
Resolution MUST output a deterministic “resolved Claim-IR” object that includes:
- ranked candidate QIDs/PIDs for entity/property surfaces,
- normalized literals with explicit type info,
- explicit representation of unresolved ambiguity,
- warnings/errors as structured, machine-readable codes.

Schema: `02-schemas/resolved-claim-ir.schema.json`

## 5.3 Validation contract (acceptance gate)
Validation MUST be deterministic and MUST:
- produce a structured validation report,
- assign stable machine-readable codes,
- block compilation if validation fails.

Schema: `02-schemas/validation-report.schema.json`

Rule: **If validation fails, compilation MUST NOT proceed.**

## 5.4 Exchange commit contract
Exchange generation MUST:
- define exactly what is included/excluded for hashing,
- define merge/incremental semantics if supported,
- preserve traceability from Exchange statements to Claim-IR and evidence.

Manifest schema: `02-schemas/exchange-manifest.schema.json`

## 5.5 Runtime Pack contract
Runtime Pack generation MUST:
- be reproducible per Section 4,
- declare all policy selections affecting query behavior and indexing,
- remain offline-executable (no network dependency required for query execution).

Manifest schema: `02-schemas/runtime-pack-manifest.schema.json`

---

# 6. Deterministic baseline exports (mandatory when implemented)

Kristal v3 defines baseline export profiles to support interoperability with Wikibase/Wikidata-shaped ecosystems.

If an implementation supports exports, it MUST support:

1. **Deterministic JSON-LD 1.1 export**
   - under a stable declared context/profile
   - byte-stable given identical inputs and policies

2. **Deterministic WDQS-compatible RDF export**
   - including a declared mapping for truthy/best-rank semantics (or explicit absence)

Export details live in:
- `05-profiles/profile-jsonld-export.md`
- `05-profiles/profile-rdf-wdqs-export.md`

---

# 7. Query semantics (core vs profile)

Runtime Packs MUST support constrained offline queries.
The detailed query contract is specified in:
- `04-query/query-contract.md`

Core requires at minimum:
- triple-pattern querying over (s, p, o) with bound/unbound fields,
- deterministic result ordering given selected ordering policy,
- deterministic paging semantics (cursor or offset) as declared.

TPF-like pagination + cardinality metadata is an optional profile:
- `05-profiles/profile-query-tpf-pagination.md`

---

# 8. Profiles and extensions

## 8.1 Profiles are explicit
Any optional capability MUST be specified as a profile.
If a profile is enabled or claimed:
- it MUST be declared in manifests,
- it MUST be testable,
- it MUST NOT redefine core identity or validation semantics.

## 8.2 RDF integrity (optional profile)
RDF Dataset Canonicalization and `rdf_hash` are OPTIONAL, due to worst-case cost.
If enabled, it MUST:
- use RDFC-1.0 canonicalization,
- gate in CI against a declared subset of tests,
- enforce resource limits, and fail closed on limit breach.

See: `05-profiles/profile-rdf-integrity-rdfc.md`

## 8.3 Provenance packaging (optional profile)
Nanopublication + PROV-O packaging is OPTIONAL.

See: `05-profiles/profile-provenance-nanopub-provo.md`

---

# 9. Compliance and test vectors (mandatory)

Implementations MUST ship and pass:
- JCS canonicalization vectors
- expected hashes for representative artifacts
- fixtures for validation pass/fail behavior
- query behavior fixtures for determinism

See: `09-test-vectors/`

---

# 10. Forward compatibility rules

- Readers MUST ignore unknown non-integrity fields.
- Readers MUST fail closed on declared integrity material that does not verify.
- Writers SHOULD avoid breaking schema changes; if unavoidable, MUST bump schema version and declare it.

---

# 11. Summary of “v3 core” obligations

A v3 core implementation MUST:
- use RFC 8785 JCS for canonical_json,
- compute content-addressed IDs from JCS with signatures excluded,
- enforce fail-closed integrity semantics,
- emit minimal reproducibility manifests,
- enforce pipeline contracts (Claim-IR, Resolution, Validation),
- produce deterministic exports when supported,
- provide test vectors and CI gating for core behaviors.

===== END 01-core-spec/kristal-v3-core-spec.md (#0004) =====

===== BEGIN 01-core-spec/signatures-trust.md (#0005) =====
# 01-core-spec/signatures-trust.md

## Status

Draft (v3)

## Purpose

This document specifies the **normative** rules for:

* signature and attestation structures used in Kristal v3 artifacts
* what is signed (and how signing payloads are constructed)
* verification requirements, including **fail-closed** semantics
* trust-root, key identity (`kid`), and offline verification expectations
* minimum interoperability requirements (mandatory-to-implement algorithms)

This document applies to:

* **Kristal Exchange** artifacts
* **Runtime Pack** manifests (and, optionally, other derived artifacts)

---

## 1. Terminology

* **Artifact**: a JSON object (Exchange or Runtime Pack manifest).
* **Content hash**: the artifact’s content-addressed hash (e.g., `kristal_id` for Exchange), computed per `01-core-spec/ids-canonicalization-hashing.md`.
* **Signature**: a cryptographic proof that binds an issuer to a signing payload.
* **Attestation**: a signature that may be produced by a third party (auditor, publisher, distributor) over an artifact payload.
* **Trust root**: a pinned set of public keys (or certificates) trusted by a verifier for a given tenant/environment.
* **Fail-closed**: if an artifact declares hashes/signatures, verification failure is a hard error; the artifact MUST NOT be treated as valid.

Normative keywords: MUST, MUST NOT, SHOULD, SHOULD NOT, MAY.

---

## 2. Core principles

1. **Content IDs are not signatures.**
   `kristal_id` proves content identity; signatures prove issuer authenticity/authorization.

2. **Signatures MUST NOT be included in the content-hash target.**
   Signatures are overlays; the content hash is computed over the artifact with signature fields excluded (see IDs/canonicalization spec).

3. **Verification must be offline-capable.**
   A verifier must be able to verify a signed artifact with no network access, given the artifact and the relevant trust roots.

4. **If declared, integrity MUST be enforced.**
   Presence of declared signatures/hashes implies fail-closed behavior.

---

## 3. Signature envelope

### 3.1 Where signatures live (normative)

Artifacts that support signatures MUST include a top-level field:

* `signatures`: an array of signature objects

If `signatures` is absent or empty, the artifact is considered **unsigned**.

### 3.2 Signature object schema (normative)

Each entry in `signatures[]` MUST be an object with:

* `kid` (string): key identifier used to locate the issuer public key in the trust store
* `alg` (string): signing algorithm identifier
* `hash_alg` (string): hash algorithm used to hash the signing payload
* `payload` (object): the signing payload (see Section 4)
* `payload_hash` (string): `"<hash_alg>:<hex>"` of the canonical payload (see Section 4)
* `sig` (string): signature bytes encoded as base64url (no padding)
* `created` (string): ISO 8601 timestamp
* `required` (boolean, optional): defaults to `true`

Optional fields (profiles / non-normative unless explicitly enabled):

* `issuer` (string): human-readable issuer name
* `expires` (string): ISO 8601 timestamp
* `x5c` (array of strings): X.509 certificate chain (base64 DER) (optional profile)
* `purpose` (string): e.g., `"publisher"`, `"auditor"`, `"distributor"`
* `notes` (string)

### 3.3 Mandatory-to-implement algorithms (interop)

To ensure interoperability, v3 implementations MUST support verification for:

* `alg = "ed25519"`
* `hash_alg = "sha256"`

Implementations MAY support additional algorithms (e.g., ECDSA P-256), but MUST NOT claim v3 conformance if they cannot verify Ed25519 + SHA-256 signatures.

---

## 4. Signing payload construction

### 4.1 Payload goals

The signature payload MUST:

* bind the issuer to the artifact’s **content identity**
* bind the issuer to the canonicalization/hash profile used
* prevent ambiguous “what exactly was signed” situations

### 4.2 Payload fields (normative)

The `payload` object MUST contain:

* `artifact_kind` (string): `"exchange"` or `"runtime_pack_manifest"`
* `artifact_version` (string): the artifact format version (e.g., `"v3"`)
* `content_id` (string):

  * Exchange: the `kristal_id` value
  * Runtime Pack manifest: the pack content-id (if defined) or a deterministic manifest id
* `canonicalization_profile` (string)
* `canonicalization_version` (string)
* `hash_alg` (string): MUST match `signatures[].hash_alg`
* `content_hash` (string): MUST be the hash portion of `content_id` or an equivalent canonical representation

Optional payload fields:

* `tenant_id` (string): tenant scope when applicable
* `environment` (string): e.g., `"prod"`, `"staging"`
* `valid_from` / `valid_until` (ISO 8601 strings)
* `policy_set_id` (string): identifier for the portable policy selections used (if you want signatures to bind to policy choices)

### 4.3 Canonicalization of payload (normative)

To compute `payload_hash`, implementations MUST:

1. canonicalize `payload` using the same canonicalization rules as the artifact (`canonicalization_profile`), i.e., JCS in v3 core
2. compute `payload_hash = sha256(canonical_payload_bytes)`
3. encode as: `payload_hash = "sha256:<lowercase-hex>"`

### 4.4 Signature computation (normative)

For `alg="ed25519"`:

* signature input MUST be the raw bytes of the SHA-256 digest of the canonical payload (32 bytes).
* `sig` MUST be base64url-encoded signature bytes (no padding).

---

## 5. Verification rules (fail-closed)

### 5.1 Verification procedure (normative)

Given an artifact `A`:

1. If `A.signatures` is absent or empty: artifact is **unsigned** (verification MAY succeed with “unsigned” status).
2. Otherwise, for each signature object `S` in `A.signatures`:

   * Validate required fields exist and are well-formed.
   * Recompute canonical payload bytes from `S.payload`.
   * Recompute `payload_hash` and compare to `S.payload_hash`.
   * Resolve the public key for `S.kid` from the verifier’s trust store.
   * Verify `S.sig` under `S.alg` using the verified `payload_hash` bytes.
3. Apply required/optional semantics:

   * If `S.required` is true or missing, it is required.
   * If any required signature fails, verification MUST fail.

### 5.2 Fail-closed semantics (normative)

If an artifact contains any signature object that is **declared** (present in `signatures[]`) and that signature is **required**, then:

* any verification failure (malformed payload, missing key, mismatch, bad signature) MUST be treated as a hard error
* the artifact MUST NOT be accepted for compilation, execution, distribution, or rendering

Unsigned artifacts MAY be accepted depending on deployment policy, but must be clearly treated as unsigned.

### 5.3 Partial verification (normative)

Verifiers MUST NOT “silently skip” signatures they cannot process if those signatures are required.

If a verifier does not support the algorithm referenced by a required signature:

* verification MUST fail (hard error)

---

## 6. Trust roots, key identity, and multi-tenancy

### 6.1 Trust roots (normative)

Each verifier MUST maintain a trust store containing:

* a set of trusted public keys (or certificates) keyed by `kid`

Trust stores MAY be:

* tenant-scoped
* environment-scoped (prod/staging)
* device-scoped (pinned to an app install)

### 6.2 `kid` format (recommended)

Recommended `kid` formats:

* stable string key IDs (e.g., `"orgo-prod-ed25519-2026-01"`)
* or key fingerprints (e.g., multibase/multihash), provided the encoding is stable

### 6.3 Key rotation (recommended)

* allow overlapping validity windows where old and new keys are trusted
* do not remove a key until artifacts signed by it are no longer accepted in that environment
* prefer short-lived signing keys with longer-lived root keys (optional profile)

---

## 7. What signatures authorize (deployment policy)

This spec binds a signature to a content identity. Whether that signature is “enough” to:

* publish Exchange into a registry
* distribute a Runtime Pack
* display “verified” badges
  is governed by product policy.

Recommended minimum policy:

* **Orgo**: is the control plane enforcing “no compile on validation fail” and signature policies for publish/release.
* **Konnaxion**: must verify signatures before activating packs when signatures are present; must pin trust roots per tenant/environment.
* **Architect**: must only render from validated artifacts; should surface signature/issuer metadata where relevant.

---

## 8. Optional attestation layers (profiles)

Implementations MAY support multiple signatures in `signatures[]`:

* publisher signature (who released it)
* auditor signature (third-party review)
* distributor signature (who served it to devices)

A deployment MAY require:

* at least one valid required signature
* or a specific `purpose` signature (e.g., `purpose="publisher"`)

If such requirements exist, they MUST be expressed in a deployment policy document (not in the artifact core schema), to keep the standard’s normative surface area small.

---

## 9. Conformance tests

A v3 implementation MUST provide test vectors that cover:

* positive verification cases (valid payload_hash + signature)
* negative cases (payload tampering, wrong key, malformed signature, unsupported alg on required signature)
* fail-closed behavior (required signature failure blocks acceptance)

Test vectors SHOULD include:

* Exchange artifacts and Runtime Pack manifests
* multiple `kid` resolutions
* multiple signatures, including required/optional mixes

---

## 10. Open questions (to finalize)

* Do we require `expires` / validity windows in core, or keep as policy-only?
* Do we require a specific `kid` canonical format (fingerprint vs string)?
* Do we standardize a transparency log / append-only ledger for published artifacts (likely a profile)?

===== END 01-core-spec/signatures-trust.md (#0005) =====

===== BEGIN 02-schemas/claim-ir.schema.json (#0006) =====
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://kristal.org/schemas/v3/claim-ir.schema.json",
  "title": "Claim-IR v3",
  "type": "object",
  "additionalProperties": false,
  "required": ["schema_version", "subject", "claims"],
  "properties": {
    "schema_version": {
      "type": "string",
      "const": "3.0"
    },

    "document": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "doc_id": { "type": "string", "minLength": 1 },
        "title": { "type": "string" },
        "lang": { "$ref": "#/$defs/lang" },

        "source_url": { "type": "string", "format": "uri" },
        "source_id": { "type": "string", "minLength": 1 },

        "retrieved_at": { "type": "string", "format": "date-time" },
        "published_at": { "type": "string", "format": "date-time" },

        "content_hash": {
          "type": "object",
          "additionalProperties": false,
          "required": ["alg", "value"],
          "properties": {
            "alg": { "type": "string", "enum": ["sha256"] },
            "value": { "type": "string", "pattern": "^[0-9a-fA-F]{64}$" }
          }
        }
      },
      "anyOf": [
        { "required": ["source_url"] },
        { "required": ["source_id"] },
        { "required": ["doc_id"] }
      ]
    },

    "extraction": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "run_id": { "type": "string", "minLength": 1 },
        "created_at": { "type": "string", "format": "date-time" },

        "producer": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "kind": { "type": "string", "enum": ["llm", "rules", "hybrid", "human"] },
            "name": { "type": "string" },
            "version": { "type": "string" }
          }
        },

        "model": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "provider": { "type": "string" },
            "name": { "type": "string" },
            "version": { "type": "string" }
          }
        },

        "prompt_ref": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "prompt_id": { "type": "string" },
            "prompt_hash": { "type": "string", "pattern": "^[0-9a-fA-F]{64}$" }
          }
        },

        "notes": { "type": "string" }
      }
    },

    "subject": { "$ref": "#/$defs/entity_ref" },

    "claims": {
      "type": "array",
      "minItems": 0,
      "items": { "$ref": "#/$defs/claim" }
    },

    "warnings": {
      "type": "array",
      "items": { "$ref": "#/$defs/warning" }
    },

    "errors": {
      "type": "array",
      "items": { "$ref": "#/$defs/error" }
    }
  },

  "$defs": {
    "qid": { "type": "string", "pattern": "^Q[1-9][0-9]*$" },
    "pid": { "type": "string", "pattern": "^P[1-9][0-9]*$" },
    "lang": { "type": "string", "pattern": "^[a-z]{2}(-[A-Z]{2})?$" },

    "entity_candidate": {
      "type": "object",
      "additionalProperties": false,
      "required": ["id", "score"],
      "properties": {
        "id": { "$ref": "#/$defs/qid" },
        "score": { "type": "number", "minimum": 0, "maximum": 1 },
        "label": { "type": "string" },
        "source": { "type": "string" }
      }
    },

    "property_candidate": {
      "type": "object",
      "additionalProperties": false,
      "required": ["id", "score"],
      "properties": {
        "id": { "$ref": "#/$defs/pid" },
        "score": { "type": "number", "minimum": 0, "maximum": 1 },
        "label": { "type": "string" },
        "source": { "type": "string" }
      }
    },

    "entity_ref": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "qid": { "$ref": "#/$defs/qid" },
        "surface": { "type": "string", "minLength": 1 },
        "lang": { "$ref": "#/$defs/lang" },
        "candidates": {
          "type": "array",
          "items": { "$ref": "#/$defs/entity_candidate" }
        }
      },
      "anyOf": [
        { "required": ["qid"] },
        { "required": ["surface"] }
      ]
    },

    "predicate_ref": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "pid": { "$ref": "#/$defs/pid" },
        "surface": { "type": "string", "minLength": 1 },
        "lang": { "$ref": "#/$defs/lang" },
        "candidates": {
          "type": "array",
          "items": { "$ref": "#/$defs/property_candidate" }
        }
      },
      "anyOf": [
        { "required": ["pid"] },
        { "required": ["surface"] }
      ]
    },

    "object_value": {
      "type": "object",
      "additionalProperties": false,
      "required": ["kind", "value"],
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["item", "string", "quantity", "time", "monolingual_text", "coord", "url"]
        },
        "value": {}
      },
      "allOf": [
        {
          "if": { "properties": { "kind": { "const": "item" } } },
          "then": { "properties": { "value": { "$ref": "#/$defs/entity_ref" } } }
        },
        {
          "if": { "properties": { "kind": { "const": "string" } } },
          "then": { "properties": { "value": { "type": "string" } } }
        },
        {
          "if": { "properties": { "kind": { "const": "url" } } },
          "then": { "properties": { "value": { "type": "string", "format": "uri" } } }
        },
        {
          "if": { "properties": { "kind": { "const": "quantity" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["amount"],
                "properties": {
                  "amount": { "type": "number" },
                  "unit_qid": { "$ref": "#/$defs/qid" },
                  "lower_bound": { "type": "number" },
                  "upper_bound": { "type": "number" }
                }
              }
            }
          }
        },
        {
          "if": { "properties": { "kind": { "const": "time" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["iso8601"],
                "properties": {
                  "iso8601": { "type": "string", "pattern": "^-?\\d{4}-\\d{2}-\\d{2}" },
                  "precision": {
                    "type": "string",
                    "enum": ["year", "month", "day", "hour", "minute", "second"]
                  },
                  "calendar": { "type": "string" },
                  "timezone": { "type": "string" }
                }
              }
            }
          }
        },
        {
          "if": { "properties": { "kind": { "const": "monolingual_text" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["text", "lang"],
                "properties": {
                  "text": { "type": "string" },
                  "lang": { "$ref": "#/$defs/lang" }
                }
              }
            }
          }
        },
        {
          "if": { "properties": { "kind": { "const": "coord" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["lat", "lon"],
                "properties": {
                  "lat": { "type": "number", "minimum": -90, "maximum": 90 },
                  "lon": { "type": "number", "minimum": -180, "maximum": 180 },
                  "globe": { "type": "string" }
                }
              }
            }
          }
        }
      ]
    },

    "evidence": {
      "type": "object",
      "additionalProperties": false,
      "required": ["source"],
      "properties": {
        "source": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "source_id": { "type": "string", "minLength": 1 },
            "source_url": { "type": "string", "format": "uri" },
            "title": { "type": "string" },
            "retrieved_at": { "type": "string", "format": "date-time" }
          },
          "anyOf": [
            { "required": ["source_url"] },
            { "required": ["source_id"] }
          ]
        },
        "quote": { "type": "string" },
        "page": { "type": "integer", "minimum": 1 },

        "offsets": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "start_char": { "type": "integer", "minimum": 0 },
            "end_char": { "type": "integer", "minimum": 0 }
          }
        },

        "selector": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "kind": { "type": "string", "enum": ["css", "xpath", "json_pointer", "pdf_region"] },
            "value": { "type": "string", "minLength": 1 }
          }
        }
      }
    },

    "uncertainty": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "confidence": { "type": "number", "minimum": 0, "maximum": 1 },
        "confidence_interval": {
          "type": "object",
          "additionalProperties": false,
          "required": ["low", "high"],
          "properties": {
            "low": { "type": "number", "minimum": 0, "maximum": 1 },
            "high": { "type": "number", "minimum": 0, "maximum": 1 }
          }
        },
        "method": { "type": "string" },
        "notes": { "type": "string" }
      }
    },

    "claim": {
      "type": "object",
      "additionalProperties": false,
      "required": ["predicate", "object"],
      "properties": {
        "claim_id": { "type": "string", "minLength": 1 },

        "predicate": { "$ref": "#/$defs/predicate_ref" },
        "object": { "$ref": "#/$defs/object_value" },

        "qualifiers": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["predicate", "object"],
            "properties": {
              "predicate": { "$ref": "#/$defs/predicate_ref" },
              "object": { "$ref": "#/$defs/object_value" }
            }
          }
        },

        "evidence": {
          "type": "array",
          "items": { "$ref": "#/$defs/evidence" }
        },

        "confidence": { "type": "number", "minimum": 0, "maximum": 1 },
        "uncertainty": { "$ref": "#/$defs/uncertainty" },

        "alternatives": {
          "type": "array",
          "items": { "$ref": "#/$defs/claim" }
        },

        "notes": { "type": "string" }
      }
    },

    "warning": {
      "type": "object",
      "additionalProperties": false,
      "required": ["code", "message"],
      "properties": {
        "code": {
          "type": "string",
          "enum": [
            "NO_CLAIMS_EXTRACTED",
            "LOW_CONFIDENCE_EXTRACTION",
            "AMBIGUOUS_SUBJECT",
            "AMBIGUOUS_PREDICATE",
            "UNRESOLVED_QID",
            "UNRESOLVED_PID",
            "EVIDENCE_MISSING",
            "EVIDENCE_WEAK",
            "VALUE_NORMALIZATION_NEEDED"
          ]
        },
        "message": { "type": "string" },
        "path": { "type": "string" }
      }
    },

    "error": {
      "type": "object",
      "additionalProperties": false,
      "required": ["code", "message"],
      "properties": {
        "code": {
          "type": "string",
          "enum": [
            "SCHEMA_INVALID",
            "REQUIRED_FIELD_MISSING",
            "UNSUPPORTED_KIND",
            "INVALID_VALUE_SHAPE"
          ]
        },
        "message": { "type": "string" },
        "path": { "type": "string" }
      }
    }
  }
}

===== END 02-schemas/claim-ir.schema.json (#0006) =====

===== BEGIN 02-schemas/exchange-manifest.schema.json (#0007) =====
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://kristal.org/schemas/v3/exchange-manifest.schema.json",
  "title": "Kristal v3 Exchange Manifest",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "schema_version",
    "kristal_id",
    "canonicalization_profile",
    "canonicalization_version",
    "content_hash",
    "build",
    "inputs"
  ],
  "properties": {
    "schema_version": {
      "type": "string",
      "const": "3.0",
      "description": "Manifest schema version."
    },

    "manifest_id": {
      "type": "string",
      "minLength": 1,
      "description": "Unique ID for this manifest (UUID or similar)."
    },

    "created_at": {
      "type": "string",
      "format": "date-time",
      "description": "UTC timestamp when the manifest was produced."
    },

    "kristal_id": {
      "type": "string",
      "minLength": 1,
      "description": "Content-addressed ID of the Exchange artifact."
    },

    "canonicalization_profile": {
      "type": "string",
      "minLength": 1,
      "description": "Canonicalization profile identifier (e.g., 'jcs-rfc8785')."
    },

    "canonicalization_version": {
      "type": "string",
      "minLength": 1,
      "description": "Canonicalization version (e.g., RFC version, implementation profile version)."
    },

    "content_hash": {
      "$ref": "#/$defs/hash",
      "description": "Hash of the canonicalized Exchange artifact with signatures excluded."
    },

    "build": {
      "$ref": "#/$defs/build",
      "description": "Deterministic build correlation and compiler identity."
    },

    "inputs": {
      "$ref": "#/$defs/inputs",
      "description": "Input snapshot identifiers and upstream artifact references."
    },

    "profiles_enabled": {
      "type": "array",
      "description": "Explicitly enabled optional profiles during compilation/validation.",
      "items": { "type": "string", "minLength": 1 }
    },

    "exports": {
      "$ref": "#/$defs/exports",
      "description": "Deterministic export declarations and (optional) export integrity hashes."
    },

    "policies": {
      "$ref": "#/$defs/policies",
      "description": "Policy selections that may affect derived artifacts; Exchange SHOULD record those relevant to reproducibility."
    },

    "signatures": {
      "type": "array",
      "description": "Optional signature set over the declared content_hash or the canonicalized payload (as defined by the signing profile).",
      "items": { "$ref": "#/$defs/signature" }
    },

    "references": {
      "type": "object",
      "description": "Optional references to specs/docs for traceability.",
      "additionalProperties": false,
      "properties": {
        "spec_version": { "type": "string", "minLength": 1 },
        "docs_uri": { "type": "string", "format": "uri" }
      }
    },

    "extensions": {
      "type": "object",
      "description": "Implementation-specific fields. Must not change core identity/hashing semantics.",
      "additionalProperties": true
    }
  },

  "$defs": {
    "sha256_hex": {
      "type": "string",
      "pattern": "^[a-fA-F0-9]{64}$"
    },

    "hash": {
      "type": "object",
      "additionalProperties": false,
      "required": ["algo", "value"],
      "properties": {
        "algo": {
          "type": "string",
          "description": "Hash algorithm identifier.",
          "enum": ["sha256"]
        },
        "value": {
          "$ref": "#/$defs/sha256_hex",
          "description": "Hex-encoded hash digest."
        }
      }
    },

    "build": {
      "type": "object",
      "additionalProperties": false,
      "required": ["build_id", "compiler_name", "compiler_version", "config_hash"],
      "properties": {
        "build_id": {
          "type": "string",
          "minLength": 1,
          "description": "Correlation ID for end-to-end tracing (shared across pipeline stages)."
        },
        "compiler_name": {
          "type": "string",
          "minLength": 1
        },
        "compiler_version": {
          "type": "string",
          "minLength": 1
        },
        "config_hash": {
          "type": "string",
          "minLength": 1,
          "description": "Hash of compilation configuration (string hash or digest)."
        },
        "git_commit": {
          "type": "string",
          "minLength": 1,
          "description": "Optional SCM commit identifier for the compiler/runtime."
        },
        "environment": {
          "type": "object",
          "description": "Optional build environment metadata (non-normative).",
          "additionalProperties": true
        }
      }
    },

    "inputs": {
      "type": "object",
      "additionalProperties": false,
      "required": ["source_snapshot_id"],
      "properties": {
        "source_snapshot_id": {
          "type": "string",
          "minLength": 1,
          "description": "Identifier of the source snapshot (documents/datasets) used to build the Exchange."
        },
        "recipe_id": {
          "type": "string",
          "minLength": 1,
          "description": "Optional subset/build recipe identifier."
        },
        "claim_ir_ids": {
          "type": "array",
          "description": "Optional list of Claim-IR artifact identifiers used.",
          "items": { "type": "string", "minLength": 1 }
        },
        "resolved_claim_ir_ids": {
          "type": "array",
          "description": "Optional list of Resolved Claim-IR artifact identifiers used.",
          "items": { "type": "string", "minLength": 1 }
        },
        "previous_exchange_ids": {
          "type": "array",
          "description": "Optional parent Exchange IDs (for incremental builds / merges).",
          "items": { "type": "string", "minLength": 1 }
        }
      }
    },

    "exports": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "jsonld": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "profile": { "type": "string", "minLength": 1 },
            "context_uri": { "type": "string", "format": "uri" },
            "export_hash": { "$ref": "#/$defs/hash" }
          }
        },
        "rdf": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "profile": { "type": "string", "minLength": 1 },
            "truthy_mode": {
              "type": "string",
              "description": "How truthy/best-rank is projected for WDQS compatibility.",
              "enum": ["none", "truthy", "best_rank"]
            },
            "rdf_hash": {
              "$ref": "#/$defs/hash",
              "description": "Optional export integrity hash when the RDFC profile is enabled."
            }
          }
        }
      }
    },

    "policies": {
      "type": "object",
      "description": "Portable policy selections. Exchange may record these for reproducibility and auditing.",
      "additionalProperties": false,
      "properties": {
        "ordering_policies": {
          "type": "array",
          "description": "Selected triple-table orderings (portable enum set).",
          "minItems": 1,
          "items": {
            "type": "string",
            "enum": ["SPO", "SOP", "PSO", "POS", "OSP", "OPS"]
          }
        },
        "row_group_policy": {
          "type": "object",
          "additionalProperties": false,
          "required": ["type"],
          "properties": {
            "type": {
              "type": "string",
              "enum": ["FIXED_ROWS", "FIXED_BYTES", "ADAPTIVE"]
            },
            "rows": { "type": "integer", "minimum": 1 },
            "bytes": { "type": "integer", "minimum": 1 },
            "target_rows": { "type": "integer", "minimum": 1 },
            "target_bytes": { "type": "integer", "minimum": 1 }
          },
          "allOf": [
            {
              "if": { "properties": { "type": { "const": "FIXED_ROWS" } } },
              "then": { "required": ["rows"] }
            },
            {
              "if": { "properties": { "type": { "const": "FIXED_BYTES" } } },
              "then": { "required": ["bytes"] }
            },
            {
              "if": { "properties": { "type": { "const": "ADAPTIVE" } } },
              "then": { "required": ["target_rows", "target_bytes"] }
            }
          ]
        },
        "membership_filter_policy": {
          "type": "object",
          "additionalProperties": false,
          "required": ["family", "key_space", "target_fpr"],
          "properties": {
            "family": { "type": "string", "enum": ["binary_fuse", "xor"] },
            "variant": { "type": "string", "enum": ["3wise", "4wise"] },
            "key_space": {
              "type": "string",
              "description": "What keys are filtered for membership checks.",
              "enum": ["claim_id", "spo_hash", "entity_id", "custom"]
            },
            "target_fpr": { "type": "number", "minimum": 0, "maximum": 1 },
            "bits_per_key": { "type": "number", "minimum": 0 },
            "seed": { "type": "integer", "minimum": 0 }
          }
        },
        "bitmap_policy": {
          "type": "object",
          "additionalProperties": false,
          "required": ["format"],
          "properties": {
            "format": { "type": "string", "enum": ["roaring"] },
            "run_opt": { "type": "boolean" }
          }
        },
        "join1_cap_policy": {
          "type": "object",
          "additionalProperties": false,
          "required": ["cap", "strict_mode"],
          "properties": {
            "cap": { "type": "integer", "minimum": 1 },
            "strict_mode": { "type": "boolean" },
            "on_exceed": {
              "type": "string",
              "enum": ["error", "truncate"],
              "description": "Deterministic behavior when strict_mode is true and cap is exceeded."
            }
          }
        }
      }
    },

    "signature": {
      "type": "object",
      "additionalProperties": false,
      "required": ["key_id", "alg", "signature"],
      "properties": {
        "key_id": {
          "type": "string",
          "minLength": 1,
          "description": "Key identifier (KID) used to verify this signature."
        },
        "alg": {
          "type": "string",
          "minLength": 1,
          "description": "Signature algorithm identifier (e.g., ed25519, rsa-pss-sha256)."
        },
        "signature": {
          "type": "string",
          "minLength": 1,
          "description": "Signature value (encoding as specified by the signing profile; commonly base64url)."
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "signer": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "name": { "type": "string", "minLength": 1 },
            "org": { "type": "string", "minLength": 1 }
          }
        },
        "certificate_uri": {
          "type": "string",
          "format": "uri",
          "description": "Optional pointer to a certificate chain or public key material."
        }
      }
    }
  }
}

===== END 02-schemas/exchange-manifest.schema.json (#0007) =====

===== BEGIN 02-schemas/resolved-claim-ir.schema.json (#0008) =====
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://kristal.org/schemas/v3/resolved-claim-ir.schema.json",
  "title": "Resolved Claim-IR v3",
  "type": "object",
  "additionalProperties": false,
  "required": ["schema_version", "input", "resolution", "subject", "claims"],
  "properties": {
    "schema_version": { "type": "string", "const": "3.0" },

    "input": {
      "type": "object",
      "additionalProperties": false,
      "required": ["claim_ir_ref"],
      "properties": {
        "claim_ir_ref": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "doc_id": { "type": "string", "minLength": 1 },
            "source_id": { "type": "string", "minLength": 1 },
            "source_url": { "type": "string", "format": "uri" },
            "run_id": { "type": "string", "minLength": 1 }
          }
        },
        "claim_ir_hash": {
          "type": "object",
          "additionalProperties": false,
          "required": ["alg", "value"],
          "properties": {
            "alg": { "type": "string", "enum": ["sha256"] },
            "value": { "type": "string", "pattern": "^[0-9a-fA-F]{64}$" }
          }
        }
      }
    },

    "resolution": {
      "type": "object",
      "additionalProperties": false,
      "required": ["run_id", "created_at", "resolver"],
      "properties": {
        "run_id": { "type": "string", "minLength": 1 },
        "created_at": { "type": "string", "format": "date-time" },

        "resolver": {
          "type": "object",
          "additionalProperties": false,
          "required": ["name", "version"],
          "properties": {
            "name": { "type": "string", "minLength": 1 },
            "version": { "type": "string", "minLength": 1 },
            "kind": {
              "type": "string",
              "enum": ["sentient", "hybrid", "human"]
            }
          }
        },

        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "timeout_ms": { "type": "integer", "minimum": 1 },
            "max_candidates": { "type": "integer", "minimum": 1 },
            "max_hops": { "type": "integer", "minimum": 0 },
            "max_calls": { "type": "integer", "minimum": 1 }
          }
        },

        "summary": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "entities_resolved": { "type": "integer", "minimum": 0 },
            "entities_ambiguous": { "type": "integer", "minimum": 0 },
            "entities_unresolved": { "type": "integer", "minimum": 0 },
            "properties_resolved": { "type": "integer", "minimum": 0 },
            "properties_ambiguous": { "type": "integer", "minimum": 0 },
            "properties_unresolved": { "type": "integer", "minimum": 0 },
            "warnings": { "type": "integer", "minimum": 0 }
          }
        },

        "notes": { "type": "string" }
      }
    },

    "subject": { "$ref": "#/$defs/entity_resolution" },

    "claims": {
      "type": "array",
      "items": { "$ref": "#/$defs/resolved_claim" }
    },

    "warnings": {
      "type": "array",
      "items": { "$ref": "#/$defs/warning" }
    },

    "errors": {
      "type": "array",
      "items": { "$ref": "#/$defs/error" }
    }
  },

  "$defs": {
    "qid": { "type": "string", "pattern": "^Q[1-9][0-9]*$" },
    "pid": { "type": "string", "pattern": "^P[1-9][0-9]*$" },
    "lang": { "type": "string", "pattern": "^[a-z]{2}(-[A-Z]{2})?$" },

    "resolution_status": {
      "type": "string",
      "enum": ["resolved", "ambiguous", "unresolved", "failed"]
    },

    "entity_candidate": {
      "type": "object",
      "additionalProperties": false,
      "required": ["id", "score"],
      "properties": {
        "id": { "$ref": "#/$defs/qid" },
        "score": { "type": "number", "minimum": 0, "maximum": 1 },
        "label": { "type": "string" },
        "description": { "type": "string" },
        "source": { "type": "string" }
      }
    },

    "property_candidate": {
      "type": "object",
      "additionalProperties": false,
      "required": ["id", "score"],
      "properties": {
        "id": { "$ref": "#/$defs/pid" },
        "score": { "type": "number", "minimum": 0, "maximum": 1 },
        "label": { "type": "string" },
        "description": { "type": "string" },
        "source": { "type": "string" }
      }
    },

    "entity_resolution": {
      "type": "object",
      "additionalProperties": false,
      "required": ["status"],
      "properties": {
        "status": { "$ref": "#/$defs/resolution_status" },

        "qid": { "$ref": "#/$defs/qid" },

        "surface": { "type": "string", "minLength": 1 },
        "lang": { "$ref": "#/$defs/lang" },

        "candidates": {
          "type": "array",
          "items": { "$ref": "#/$defs/entity_candidate" }
        },

        "decision": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "method": {
              "type": "string",
              "enum": ["exact_match", "alias_match", "embedding_rank", "judge", "human"]
            },
            "score_threshold": { "type": "number", "minimum": 0, "maximum": 1 },
            "chosen_candidate_index": { "type": "integer", "minimum": 0 },
            "notes": { "type": "string" }
          }
        },

        "warnings": {
          "type": "array",
          "items": { "$ref": "#/$defs/warning" }
        }
      },
      "allOf": [
        {
          "if": { "properties": { "status": { "const": "resolved" } } },
          "then": { "required": ["qid"] }
        },
        {
          "if": { "properties": { "status": { "enum": ["ambiguous", "unresolved"] } } },
          "then": {
            "anyOf": [
              { "required": ["surface"] },
              { "required": ["candidates"] }
            ]
          }
        }
      ]
    },

    "predicate_resolution": {
      "type": "object",
      "additionalProperties": false,
      "required": ["status"],
      "properties": {
        "status": { "$ref": "#/$defs/resolution_status" },

        "pid": { "$ref": "#/$defs/pid" },

        "surface": { "type": "string", "minLength": 1 },
        "lang": { "$ref": "#/$defs/lang" },

        "candidates": {
          "type": "array",
          "items": { "$ref": "#/$defs/property_candidate" }
        },

        "decision": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "method": {
              "type": "string",
              "enum": ["exact_match", "alias_match", "embedding_rank", "judge", "human"]
            },
            "score_threshold": { "type": "number", "minimum": 0, "maximum": 1 },
            "chosen_candidate_index": { "type": "integer", "minimum": 0 },
            "notes": { "type": "string" }
          }
        },

        "warnings": {
          "type": "array",
          "items": { "$ref": "#/$defs/warning" }
        }
      },
      "allOf": [
        {
          "if": { "properties": { "status": { "const": "resolved" } } },
          "then": { "required": ["pid"] }
        },
        {
          "if": { "properties": { "status": { "enum": ["ambiguous", "unresolved"] } } },
          "then": {
            "anyOf": [
              { "required": ["surface"] },
              { "required": ["candidates"] }
            ]
          }
        }
      ]
    },

    "normalized_value": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "notes": { "type": "string" }
      }
    },

    "object_value": {
      "type": "object",
      "additionalProperties": false,
      "required": ["kind", "value"],
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["item", "string", "quantity", "time", "monolingual_text", "coord", "url"]
        },
        "value": {},
        "normalized": { "$ref": "#/$defs/normalized_value" }
      },
      "allOf": [
        {
          "if": { "properties": { "kind": { "const": "item" } } },
          "then": {
            "properties": { "value": { "$ref": "#/$defs/entity_resolution" } }
          }
        },
        {
          "if": { "properties": { "kind": { "const": "string" } } },
          "then": { "properties": { "value": { "type": "string" } } }
        },
        {
          "if": { "properties": { "kind": { "const": "url" } } },
          "then": { "properties": { "value": { "type": "string", "format": "uri" } } }
        },
        {
          "if": { "properties": { "kind": { "const": "quantity" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["amount"],
                "properties": {
                  "amount": { "type": "number" },
                  "unit_qid": { "$ref": "#/$defs/qid" },
                  "lower_bound": { "type": "number" },
                  "upper_bound": { "type": "number" }
                }
              }
            }
          }
        },
        {
          "if": { "properties": { "kind": { "const": "time" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["iso8601"],
                "properties": {
                  "iso8601": { "type": "string", "pattern": "^-?\\d{4}-\\d{2}-\\d{2}" },
                  "precision": {
                    "type": "string",
                    "enum": ["year", "month", "day", "hour", "minute", "second"]
                  },
                  "calendar": { "type": "string" },
                  "timezone": { "type": "string" }
                }
              }
            }
          }
        },
        {
          "if": { "properties": { "kind": { "const": "monolingual_text" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["text", "lang"],
                "properties": {
                  "text": { "type": "string" },
                  "lang": { "$ref": "#/$defs/lang" }
                }
              }
            }
          }
        },
        {
          "if": { "properties": { "kind": { "const": "coord" } } },
          "then": {
            "properties": {
              "value": {
                "type": "object",
                "additionalProperties": false,
                "required": ["lat", "lon"],
                "properties": {
                  "lat": { "type": "number", "minimum": -90, "maximum": 90 },
                  "lon": { "type": "number", "minimum": -180, "maximum": 180 },
                  "globe": { "type": "string" }
                }
              }
            }
          }
        }
      ]
    },

    "evidence_ref": {
      "type": "object",
      "additionalProperties": false,
      "required": ["source"],
      "properties": {
        "source": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "source_id": { "type": "string", "minLength": 1 },
            "source_url": { "type": "string", "format": "uri" },
            "title": { "type": "string" },
            "retrieved_at": { "type": "string", "format": "date-time" }
          },
          "anyOf": [{ "required": ["source_url"] }, { "required": ["source_id"] }]
        },
        "quote": { "type": "string" },
        "page": { "type": "integer", "minimum": 1 },
        "offsets": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "start_char": { "type": "integer", "minimum": 0 },
            "end_char": { "type": "integer", "minimum": 0 }
          }
        }
      }
    },

    "uncertainty": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "confidence": { "type": "number", "minimum": 0, "maximum": 1 },
        "method": { "type": "string" },
        "notes": { "type": "string" }
      }
    },

    "resolved_claim": {
      "type": "object",
      "additionalProperties": false,
      "required": ["claim_id", "predicate", "object"],
      "properties": {
        "claim_id": { "type": "string", "minLength": 1 },

        "predicate": { "$ref": "#/$defs/predicate_resolution" },
        "object": { "$ref": "#/$defs/object_value" },

        "qualifiers": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["predicate", "object"],
            "properties": {
              "predicate": { "$ref": "#/$defs/predicate_resolution" },
              "object": { "$ref": "#/$defs/object_value" }
            }
          }
        },

        "evidence": {
          "type": "array",
          "items": { "$ref": "#/$defs/evidence_ref" }
        },

        "uncertainty": { "$ref": "#/$defs/uncertainty" },

        "notes": { "type": "string" }
      }
    },

    "warning": {
      "type": "object",
      "additionalProperties": false,
      "required": ["code", "message"],
      "properties": {
        "code": {
          "type": "string",
          "enum": [
            "AMBIGUOUS_SUBJECT",
            "AMBIGUOUS_PREDICATE",
            "UNRESOLVED_QID",
            "UNRESOLVED_PID",
            "VALUE_NORMALIZATION_NEEDED",
            "LOW_CONFIDENCE_RESOLUTION",
            "LIMIT_REACHED",
            "EVIDENCE_WEAK"
          ]
        },
        "message": { "type": "string" },
        "path": { "type": "string" }
      }
    },

    "error": {
      "type": "object",
      "additionalProperties": false,
      "required": ["code", "message"],
      "properties": {
        "code": {
          "type": "string",
          "enum": [
            "SCHEMA_INVALID",
            "RESOLUTION_FAILED",
            "INVALID_VALUE_SHAPE",
            "UNSUPPORTED_KIND"
          ]
        },
        "message": { "type": "string" },
        "path": { "type": "string" }
      }
    }
  }
}

===== END 02-schemas/resolved-claim-ir.schema.json (#0008) =====

===== BEGIN 02-schemas/runtime-pack-manifest.schema.json (#0009) =====
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.org/kristal/v3/schemas/runtime-pack-manifest.schema.json",
  "title": "Kristal v3 Runtime Pack Manifest",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "manifest_version",
    "runtime_pack_id",
    "created_at",
    "exchange_ref",
    "compiler",
    "build",
    "policies",
    "files"
  ],
  "properties": {
    "manifest_version": {
      "type": "string",
      "description": "Runtime Pack manifest schema version.",
      "pattern": "^3\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-[0-9A-Za-z.-]+)?$"
    },

    "runtime_pack_id": {
      "type": "string",
      "description": "Content-addressed ID for this runtime pack (sha256 hex).",
      "pattern": "^[a-f0-9]{64}$"
    },

    "created_at": {
      "type": "string",
      "format": "date-time",
      "description": "RFC 3339 timestamp when the runtime pack was produced."
    },

    "profiles": {
      "type": "array",
      "description": "Optional standardized profiles this pack claims conformance to.",
      "items": {
        "type": "string",
        "minLength": 1
      },
      "uniqueItems": true
    },

    "exchange_ref": {
      "type": "object",
      "additionalProperties": false,
      "required": ["exchange_id"],
      "properties": {
        "exchange_id": {
          "type": "string",
          "description": "Content-addressed ID of the Kristal Exchange this pack was compiled from (sha256 hex).",
          "pattern": "^[a-f0-9]{64}$"
        },
        "exchange_manifest_hash": {
          "type": "string",
          "description": "Optional hash of the Exchange manifest referenced by this pack (sha256 hex).",
          "pattern": "^[a-f0-9]{64}$"
        },
        "exchange_version": {
          "type": "string",
          "description": "Optional human version label for Exchange (if used).",
          "minLength": 1
        }
      }
    },

    "compiler": {
      "type": "object",
      "additionalProperties": false,
      "required": ["name", "version"],
      "properties": {
        "name": { "type": "string", "minLength": 1 },
        "version": { "type": "string", "minLength": 1 },
        "git_commit": {
          "type": "string",
          "description": "Optional compiler source revision.",
          "minLength": 7
        },
        "build_platform": {
          "type": "string",
          "description": "Optional platform identifier (e.g., linux-x86_64).",
          "minLength": 1
        }
      }
    },

    "build": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "build_id",
        "deterministic",
        "canonicalization_profile",
        "config_hash"
      ],
      "properties": {
        "build_id": {
          "type": "string",
          "description": "Opaque build correlation ID (UUID or other stable identifier).",
          "minLength": 8
        },
        "deterministic": {
          "type": "boolean",
          "description": "True if this pack claims deterministic/reproducible build behavior under recorded policies.",
          "const": true
        },
        "canonicalization_profile": {
          "type": "string",
          "description": "Canonicalization profile identifier used for any hashed JSON objects.",
          "enum": ["jcs-rfc8785@1"]
        },
        "config_hash": {
          "type": "string",
          "description": "Content hash of the compiler configuration that affects outputs (sha256 hex).",
          "pattern": "^[a-f0-9]{64}$"
        }
      }
    },

    "policies": {
      "type": "object",
      "description": "Enumerated, v3-portable policies and their parameters. These fields MUST be sufficient to reproduce the pack.",
      "additionalProperties": false,
      "required": ["data_ordering", "row_grouping", "membership_filter", "bitmap"],
      "properties": {
        "data_ordering": {
          "type": "object",
          "additionalProperties": false,
          "required": ["policy"],
          "properties": {
            "policy": {
              "type": "string",
              "description": "Portable ordering policy for deterministic Parquet output.",
              "enum": [
                "qid_pid_statement_id_asc",
                "lexicographic_sop_asc",
                "none"
              ]
            },
            "notes": { "type": "string" }
          }
        },

        "row_grouping": {
          "type": "object",
          "additionalProperties": false,
          "required": ["policy"],
          "properties": {
            "policy": {
              "type": "string",
              "description": "Portable row-group sizing policy for deterministic Parquet layout.",
              "enum": [
                "fixed_rows_100k",
                "fixed_rows_1m",
                "fixed_bytes_128mb"
              ]
            },
            "notes": { "type": "string" }
          }
        },

        "membership_filter": {
          "description": "Membership filter policy used by the pack (if any) and the parameters required to reproduce it.",
          "oneOf": [
            {
              "type": "object",
              "additionalProperties": false,
              "required": ["kind"],
              "properties": {
                "kind": { "type": "string", "const": "none" }
              }
            },
            {
              "type": "object",
              "additionalProperties": false,
              "required": ["kind", "seed", "bits_per_key"],
              "properties": {
                "kind": { "type": "string", "const": "bloom" },
                "seed": { "type": "integer", "minimum": 0 },
                "bits_per_key": { "type": "integer", "minimum": 1 },
                "hash_functions": { "type": "integer", "minimum": 1 },
                "notes": { "type": "string" }
              }
            },
            {
              "type": "object",
              "additionalProperties": false,
              "required": ["kind", "seed", "fingerprint_bits", "load_factor"],
              "properties": {
                "kind": { "type": "string", "const": "cuckoo" },
                "seed": { "type": "integer", "minimum": 0 },
                "fingerprint_bits": { "type": "integer", "minimum": 4 },
                "load_factor": { "type": "number", "minimum": 0.01, "maximum": 0.99 },
                "notes": { "type": "string" }
              }
            },
            {
              "type": "object",
              "additionalProperties": false,
              "required": ["kind", "seed", "bits"],
              "properties": {
                "kind": { "type": "string", "enum": ["xor8", "xor16"] },
                "seed": { "type": "integer", "minimum": 0 },
                "bits": { "type": "integer", "enum": [8, 16] },
                "notes": { "type": "string" }
              }
            }
          ]
        },

        "bitmap": {
          "type": "object",
          "additionalProperties": false,
          "required": ["format"],
          "properties": {
            "format": {
              "type": "string",
              "description": "Portable bitmap/index encoding convention for deterministic runtime behavior.",
              "enum": [
                "roaring",
                "roaring_run_optimized"
              ]
            },
            "run_optimize": {
              "type": "boolean",
              "description": "Whether run optimization was applied (must be recorded for reproducibility)."
            },
            "notes": { "type": "string" }
          }
        },

        "parquet": {
          "type": "object",
          "description": "Parquet-level policies that affect deterministic output. Keep to portable, enumerated values.",
          "additionalProperties": false,
          "properties": {
            "compression": {
              "type": "string",
              "enum": ["zstd", "snappy", "gzip", "none"]
            },
            "dictionary_encoding": { "type": "boolean" },
            "statistics": {
              "type": "string",
              "enum": ["none", "page", "rowgroup"]
            },
            "bloom_filters": {
              "type": "object",
              "description": "Optional Parquet Bloom filter configuration (profile-bound).",
              "additionalProperties": false,
              "required": ["enabled"],
              "properties": {
                "enabled": { "type": "boolean" },
                "fpp": {
                  "type": "number",
                  "minimum": 0.0000001,
                  "maximum": 0.5,
                  "description": "False positive probability target."
                },
                "columns": {
                  "type": "array",
                  "items": { "type": "string", "minLength": 1 },
                  "uniqueItems": true
                }
              }
            }
          }
        }
      }
    },

    "query_contract": {
      "type": "object",
      "description": "Optional declaration of the offline query contract supported by this pack.",
      "additionalProperties": false,
      "properties": {
        "contract_id": { "type": "string", "minLength": 1 },
        "supports_pagination": { "type": "boolean" },
        "supports_cardinality_estimates": { "type": "boolean" }
      }
    },

    "files": {
      "type": "array",
      "minItems": 1,
      "description": "All physical files included in the runtime pack, with integrity metadata.",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["path", "role", "sha256", "size_bytes"],
        "properties": {
          "path": {
            "type": "string",
            "minLength": 1,
            "description": "Relative path within the runtime pack container."
          },
          "role": {
            "type": "string",
            "enum": [
              "parquet_data",
              "bitmap_index",
              "membership_filter",
              "dictionary",
              "metadata",
              "other"
            ]
          },
          "sha256": {
            "type": "string",
            "pattern": "^[a-f0-9]{64}$"
          },
          "size_bytes": {
            "type": "integer",
            "minimum": 0
          },
          "mime_type": { "type": "string" }
        }
      }
    },

    "integrity": {
      "type": "object",
      "description": "Optional higher-level integrity metadata for the pack as a whole.",
      "additionalProperties": false,
      "properties": {
        "hash_alg": { "type": "string", "const": "sha256" },
        "pack_sha256": {
          "type": "string",
          "description": "Optional hash of the full pack container (sha256 hex).",
          "pattern": "^[a-f0-9]{64}$"
        },
        "manifest_sha256": {
          "type": "string",
          "description": "Optional hash of this manifest content (sha256 hex).",
          "pattern": "^[a-f0-9]{64}$"
        }
      }
    },

    "signatures": {
      "type": "array",
      "description": "Optional signatures over declared hashed material (verification is fail-closed when signatures are declared).",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["key_id", "alg", "signature"],
        "properties": {
          "key_id": { "type": "string", "minLength": 1 },
          "alg": {
            "type": "string",
            "description": "Signature algorithm identifier.",
            "enum": ["ed25519", "rsa-pss-sha256", "ecdsa-p256-sha256"]
          },
          "signature": {
            "type": "string",
            "description": "Base64-encoded signature bytes.",
            "minLength": 16
          },
          "created_at": { "type": "string", "format": "date-time" }
        }
      }
    }
  }
}

===== END 02-schemas/runtime-pack-manifest.schema.json (#0009) =====

===== BEGIN 02-schemas/validation-report.schema.json (#0010) =====
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://kristal.org/schemas/v3/validation-report.schema.json",
  "title": "Kristal v3 Validation Report",
  "type": "object",
  "additionalProperties": false,
  "required": ["schema_version", "validation_status", "issues"],
  "properties": {
    "schema_version": {
      "type": "string",
      "description": "Schema version for this report format.",
      "const": "3.0"
    },

    "report_id": {
      "type": "string",
      "description": "Unique identifier for this validation report (UUID or similar).",
      "minLength": 1
    },

    "created_at": {
      "type": "string",
      "format": "date-time",
      "description": "UTC timestamp when the report was produced."
    },

    "kristal_id": {
      "type": "string",
      "description": "Content-addressed ID of the Exchange artifact being validated.",
      "minLength": 1
    },

    "build_id": {
      "type": "string",
      "description": "Compiler/build correlation ID for end-to-end traceability.",
      "minLength": 1
    },

    "validation_status": {
      "type": "string",
      "description": "Overall deterministic outcome for compilation gating.",
      "enum": ["passed", "partial", "failed"]
    },

    "profiles": {
      "type": "array",
      "description": "Profiles enabled during validation (core is implicit).",
      "items": {
        "type": "string",
        "minLength": 1
      }
    },

    "tooling": { "$ref": "#/$defs/tooling" },

    "inputs": {
      "type": "object",
      "description": "Optional identifiers for the validated artifacts and snapshots.",
      "additionalProperties": false,
      "properties": {
        "exchange_uri": { "type": "string", "format": "uri" },
        "runtime_pack_uri": { "type": "string", "format": "uri" },
        "source_snapshot_id": { "type": "string", "minLength": 1 },
        "recipe_id": { "type": "string", "minLength": 1 }
      }
    },

    "stats": {
      "type": "object",
      "description": "Summary counts for quick gating and dashboards.",
      "additionalProperties": false,
      "properties": {
        "error_count": { "type": "integer", "minimum": 0 },
        "warning_count": { "type": "integer", "minimum": 0 },
        "info_count": { "type": "integer", "minimum": 0 }
      }
    },

    "limits": {
      "type": "object",
      "description": "Resource limits applied during validation (especially for expensive profiles).",
      "additionalProperties": false,
      "properties": {
        "timeout_ms": { "type": "integer", "minimum": 0 },
        "iteration_cap": { "type": "integer", "minimum": 0 },
        "memory_cap_bytes": { "type": "integer", "minimum": 0 }
      }
    },

    "issues": {
      "type": "array",
      "description": "Deterministic issues emitted by validation (codes + locations).",
      "items": { "$ref": "#/$defs/issue" }
    },

    "shacl": {
      "type": "object",
      "description": "Optional SHACL validation output (profile extension).",
      "additionalProperties": false,
      "properties": {
        "enabled": { "type": "boolean" },
        "report_uri": { "type": "string", "format": "uri" },
        "report_format": {
          "type": "string",
          "description": "Serialization format of the report if report_uri is provided.",
          "enum": ["text/turtle", "application/n-triples", "application/n-quads", "application/ld+json", "application/rdf+xml"]
        }
      }
    },

    "shex": {
      "type": "object",
      "description": "Optional ShEx validation output (profile extension).",
      "additionalProperties": false,
      "properties": {
        "enabled": { "type": "boolean" },
        "report_uri": { "type": "string", "format": "uri" },
        "report_format": {
          "type": "string",
          "enum": ["application/json", "text/plain"]
        }
      }
    },

    "export_validation": {
      "type": "object",
      "description": "Optional results for validating deterministic exports (JSON-LD/RDF/WDQS profile checks).",
      "additionalProperties": false,
      "properties": {
        "jsonld_profile": { "type": "string", "minLength": 1 },
        "rdf_profile": { "type": "string", "minLength": 1 },
        "wdqs_compat": { "type": "boolean" },
        "rdf_hash": {
          "type": "string",
          "description": "Optional rdf_hash when RDFC integrity profile is enabled.",
          "minLength": 1
        }
      }
    },

    "extensions": {
      "type": "object",
      "description": "Implementation-specific additional fields. Must not affect core conformance semantics.",
      "additionalProperties": true
    }
  },

  "$defs": {
    "tooling": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "validator_name": { "type": "string", "minLength": 1 },
        "validator_version": { "type": "string", "minLength": 1 },
        "compiler_name": { "type": "string", "minLength": 1 },
        "compiler_version": { "type": "string", "minLength": 1 },
        "canonicalization_profile": { "type": "string", "minLength": 1 },
        "canonicalization_version": { "type": "string", "minLength": 1 }
      }
    },

    "severity": {
      "type": "string",
      "enum": ["ERROR", "WARNING", "INFO"]
    },

    "entity_id": {
      "type": "string",
      "description": "Wikidata/Wikibase entity identifiers (item/property/lexeme/form/sense) or local placeholders.",
      "pattern": "^(Q[1-9][0-9]*|P[1-9][0-9]*|L[1-9][0-9]*|L[1-9][0-9]*-[FS][1-9][0-9]*|[A-Za-z][A-Za-z0-9._:-]{0,127})$"
    },

    "json_pointer": {
      "type": "string",
      "description": "RFC 6901 JSON Pointer into Exchange / manifest / report objects.",
      "pattern": "^/.*"
    },

    "issue_location": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "json_pointer": { "$ref": "#/$defs/json_pointer" },
        "entity_id": { "$ref": "#/$defs/entity_id" },
        "statement_id": { "type": "string", "minLength": 1 },
        "claim_id": { "type": "string", "minLength": 1 },
        "evidence_id": { "type": "string", "minLength": 1 },
        "source_uri": { "type": "string", "format": "uri" }
      }
    },

    "issue": {
      "type": "object",
      "additionalProperties": false,
      "required": ["severity", "code", "message"],
      "properties": {
        "severity": { "$ref": "#/$defs/severity" },

        "code": {
          "type": "string",
          "description": "Stable machine-readable code (used for gating, dashboards, and mappings to SHACL/ShEx).",
          "minLength": 1,
          "pattern": "^[A-Z0-9_]+$"
        },

        "message": {
          "type": "string",
          "description": "Human-readable explanation of the issue.",
          "minLength": 1
        },

        "location": { "$ref": "#/$defs/issue_location" },

        "rule": {
          "type": "object",
          "description": "Optional rule metadata for deterministic debugging and traceability.",
          "additionalProperties": false,
          "properties": {
            "rule_id": { "type": "string", "minLength": 1 },
            "rule_version": { "type": "string", "minLength": 1 },
            "profile": { "type": "string", "minLength": 1 }
          }
        },

        "details": {
          "type": "object",
          "description": "Optional structured details (must remain deterministic for the same inputs).",
          "additionalProperties": true
        }
      }
    }
  }
}

===== END 02-schemas/validation-report.schema.json (#0010) =====

===== BEGIN 03-reproducibility/allowed-runtime-pack-policies.md (#0011) =====
# Allowed Runtime Pack Policies (Kristal v3)

## Status
Draft (normative for v3 portability)

## Purpose
Kristal v3 aims to keep the **determinism surface area small** while still enabling high-performance offline execution. To avoid “compliant but incomparable” packs, v3 defines a **portable enumerated policy set** for Runtime Pack construction.

A v3 Runtime Pack MUST:
1. Select policy values from the allowed sets below, and  
2. Record those selections in the Runtime Pack manifest under `policy_selections`.

Anything outside these policies is either:
- a **non-normative implementation detail**, or
- an **optional profile extension** that MUST be explicitly declared and must not change core IDs unless included in the declared reproducibility surface.

## Normative language
The key words **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as normative requirements.

---

# 1. Policy recording requirements

## 1.1 Manifest structure (minimum)
The Runtime Pack manifest MUST include:

- `policy_selections.version` (e.g., `"v3.0"`)
- `policy_selections.ordering`
- `policy_selections.row_groups`
- `policy_selections.membership_filters`
- `policy_selections.bitmaps`
- `policy_selections.query_limits`

Implementations MAY include additional policy keys, but MUST NOT omit the keys above.

## 1.2 Determinism requirement
Given identical:
- inputs (same snapshots),
- compiler version + config hash,
- and the **same policy selections**,

then the resulting Runtime Pack MUST be reproducible (see `03-reproducibility/reproducibility-acceptance-tests.md`).

---

# 2. Ordering policies (portable)

Ordering is treated as an index. Runtime Pack builders MUST pick from the following ordering policies for the Parquet triples table.

## 2.1 Allowed orderings
The allowed base orderings are:

- `SPO`
- `SOP`
- `PSO`
- `POS`
- `OSP`
- `OPS`

## 2.2 Composite ordering sets
Implementations MAY build multiple ordered copies or indexes, expressed as a set:

- `ORDER_SET([SPO, POS])`
- `ORDER_SET([SPO])` (equivalent to single ordering)

If `ORDER_SET` is used, its ordering list MUST be recorded in a stable canonical order in the manifest (e.g., lexicographic).

## 2.3 Tie-breakers (mandatory)
For deterministic ordering, a tie-breaker chain MUST be declared:

- Primary keys: the chosen ordering (e.g., s then p then o)
- Tie-breaker: `claim_id` (or an equivalent stable statement identifier)
- Final tie-breaker: stable byte comparison of the serialized triple key (implementation-defined but deterministic)

---

# 3. Row-group sizing policies (portable)

Row-group policy impacts scan behavior and Parquet block indexes.

## 3.1 Allowed row-group modes
One of the following MUST be selected:

- `FIXED_ROWS(n)`  
- `FIXED_BYTES(n)`  
- `ADAPTIVE(target_rows, target_bytes, max_variance)`  

## 3.2 Constraints
- `n`, `target_rows`, `target_bytes`, and `max_variance` MUST be recorded.
- `ADAPTIVE` MUST be deterministic and MUST NOT depend on unstable runtime factors (e.g., CPU count).
- Builders SHOULD provide recommended defaults (non-normative).

---

# 4. Membership filter policies (portable)

Membership filters accelerate scans by quickly rejecting “not present” membership queries.
They are probabilistic, so v3 makes determinism requirements explicit.

## 4.1 Allowed filter families
One of the following families MAY be used:

- `BINARY_FUSE` (RECOMMENDED default)
- `XOR_FILTER` (OPTIONAL)

If no membership filter is used, the policy MUST be explicitly recorded as:

- `NONE`

## 4.2 Key spaces (portable)
The manifest MUST declare which key spaces are filtered. Allowed key spaces:

- `CLAIM_ID` (filter over statement identifiers)
- `SPO_KEY` (filter over a canonical triple key encoding)
- `SO_KEY` (optional: subject-object key encoding)
- `SP_KEY` (optional: subject-property key encoding)
- `PO_KEY` (optional: property-object key encoding)

Builders MUST declare the encoding for each key space and ensure it is deterministic.

## 4.3 Required parameters
For any non-NONE membership filter, the manifest MUST record:

- `family` (`BINARY_FUSE` or `XOR_FILTER`)
- `variant` (e.g., `3_WISE` or `4_WISE`, where applicable)
- `seed` (or a seed array if required by the family)
- `bits_per_key` OR an equivalent explicit sizing parameter
- `target_false_positive_rate` (if applicable)
- `key_spaces` (list of key spaces covered)

## 4.4 False positives (mandatory pruning rule)
Membership filters MAY return false positives. Therefore:

- A “membership hit” MUST NOT be treated as proof of membership.
- Implementations MUST deterministically prune false positives by validating against authoritative data (the triples table / index).
- No probabilistic acceptance is permitted at the semantic layer.

---

# 5. Bitmap index policies (portable)

Bitmaps accelerate joins and multi-value lookups.

## 5.1 Allowed bitmap format
- The allowed bitmap encoding is `ROARING`.

## 5.2 Run optimization
- `ROARING_RUN_OPT` SHOULD be enabled when it reduces size or improves scan speed.
- If enabled, it MUST be recorded as:

  - `run_optimization: ENABLED`

- If not enabled:

  - `run_optimization: DISABLED`

## 5.3 Container statistics (profile extension)
Recording container statistics (for cost modeling) is an OPTIONAL profile extension:

- `bitmap_container_stats: ENABLED|DISABLED`

If enabled, it MUST be declared as a profile and MUST NOT affect core identity unless included in the reproducibility surface.

---

# 6. Parquet-level policies (portable core vs profile)

## 6.1 Parquet schema invariants (portable core)
- Column names and logical types for the triples table MUST follow the v3 runtime schema definition (defined elsewhere).
- Sorting declaration MUST match the chosen ordering policy.

## 6.2 Bloom filters (optional profile)
Parquet Bloom filters MAY be enabled as an optional performance profile:

- `parquet_bloom_filters: ENABLED|DISABLED`

If enabled, the manifest MUST record:
- which columns have bloom filters,
- bloom filter sizing parameters,
- and any hashing seeds (if applicable).

Bloom filters MUST NOT be required for core conformance.

---

# 7. Query limits and strictness (portable)

Runtime Packs are not full SPARQL. To reduce cross-implementation divergence, v3 requires explicit query limits.

## 7.1 join1 cap policy (mandatory)
The manifest MUST declare:

- `join1_cap.default` (integer)
- `join1_cap.mode` in `{STRICT, TRUNCATE}`

### Semantics
- `STRICT`: exceeding the cap MUST produce a deterministic error code.
- `TRUNCATE`: exceeding the cap MUST return a deterministic truncated result set AND a deterministic warning flag.

## 7.2 Paging mode (mandatory)
The manifest MUST declare exactly one:

- `paging: CURSOR`
- `paging: OFFSET`

If `CURSOR`, cursor encoding MUST be deterministic and stable for the selected ordering policy.

---

# 8. Policy versioning

- `policy_selections.version` MUST be present.
- Any change to enumerations or semantics MUST bump the policy version.
- Implementations MUST reject unknown policy versions unless explicitly configured to allow them.

---

# 9. Summary (portable minimum)

A v3 Runtime Pack MUST record, at minimum:
- ordering policy (and tie-breakers),
- row-group policy,
- membership filter policy (or NONE) + parameters,
- bitmap policy + run optimization flag,
- query limits (join1 cap) + strictness,
- paging mode.

These policies define the **portable comparability surface** for Runtime Packs in v3.

===== END 03-reproducibility/allowed-runtime-pack-policies.md (#0011) =====

===== BEGIN 03-reproducibility/deterministic-build-rules.md (#0012) =====
# Deterministic build rules (Kristal v3)

## Status
Normative (v3 core)

## Purpose

This document defines the **deterministic build requirements** for producing Kristal v3 artifacts, specifically:
- **Kristal Exchange** (canonical source of truth)
- **Kristal Runtime Pack** (derived offline-executable index)

The goal is **interoperability and reproducibility**: independent implementations MUST be able to rebuild artifacts with **bit-identical outputs** when given identical inputs and the same recorded policies.

## Scope

These rules apply to:
- the compilation pipeline stages that produce Exchange and Runtime Pack artifacts
- all content-addressed IDs and signatures associated with these artifacts
- manifests and files that claim deterministic outputs

These rules do **not** mandate a specific runtime performance strategy. They mandate that whatever strategy is used must be selected from **portable, enumerated policies** and must be **fully recorded** to enable reproducibility.

## Definitions

- **Deterministic build:** given the same input snapshot and the same recorded policies/parameters, the compiler produces identical outputs.
- **Reproducible build:** a third party can rerun the compiler using only the recorded manifests + referenced inputs and reproduce the exact outputs.
- **Input snapshot:** the complete set of inputs used for compilation, including Claim-IR, Resolved Claim-IR, validation rulesets, and referenced evidence blobs (where applicable).
- **Portable policy:** an allowed, enumerated policy defined in `03-reproducibility/allowed-runtime-pack-policies.md`.

## Normative requirements

### 1) Determinism declaration

1.1 A Runtime Pack MUST declare whether it is deterministic.  
1.2 Kristal v3 Runtime Packs claiming v3 core conformance MUST set `build.deterministic = true` in the Runtime Pack Manifest.  
1.3 If an implementation cannot guarantee determinism for a given build, it MUST either:
- refuse to emit a v3 core-conformant pack, or
- emit a pack under a non-core profile that explicitly states non-deterministic behavior.

### 2) Canonicalization and hashing dependencies

2.1 Any JSON objects used for content-addressed IDs MUST be canonicalized using the declared canonicalization profile.  
2.2 v3 core requires `canonicalization_profile = "jcs-rfc8785@1"`.  
2.3 The hashed material MUST exclude any `signatures` field(s) and MUST otherwise match the “hashed material definition” for the relevant artifact (Exchange vs Runtime Pack).  
2.4 If a manifest declares hashes/signatures and verification fails, consumers MUST fail-closed (see `01-core-spec/signatures-trust.md`).

### 3) Input snapshot is part of determinism

3.1 A deterministic build MUST be parameterized by an explicit input snapshot.  
3.2 The Runtime Pack Manifest MUST reference the Exchange it was compiled from (`exchange_ref.exchange_id`).  
3.3 The compiler configuration that affects outputs MUST be hashed and recorded (`build.config_hash`).  
3.4 Any “implicit inputs” (defaults, environment variables, locale, system time) that affect output MUST be eliminated or explicitly recorded.

### 4) Ordering determinism (no unstable iteration)

4.1 The compiler MUST NOT rely on non-deterministic iteration order (e.g., hash maps without sorted traversal).  
4.2 All collections that affect output bytes MUST be processed in a deterministic order defined by an allowed ordering policy.

4.3 If an ordering policy is used, it MUST be recorded in the Runtime Pack Manifest under `policies.data_ordering`.

### 5) Portable, enumerated policies (small surface area)

5.1 Build-affecting behaviors MUST be chosen from the allowed policy set defined in `03-reproducibility/allowed-runtime-pack-policies.md`.  
5.2 If a required behavior is not covered by an allowed policy, the implementation MUST:
- propose a new policy for standardization, or
- emit a non-core profile pack that does not claim v3 core conformance.

This requirement exists to prevent “technically reproducible but practically incomparable” builds.

### 6) Parquet determinism (layout and encoding)

6.1 If Parquet is used, deterministic builds MUST:
- use a portable `data_ordering` policy
- use a portable `row_grouping` policy
- record Parquet encoding settings that affect file bytes (compression, dictionary encoding, stats, bloom filters if enabled)

6.2 The exact Parquet-related settings MUST be recorded in the Runtime Pack Manifest under `policies.parquet`.

6.3 If bloom filters are enabled, they MUST be treated as profile-bound unless explicitly included in v3 core allowed policies.

### 7) Membership filters and bitmaps determinism

7.1 If the pack includes membership filters (Bloom/Cuckoo/Xor), the kind and all parameters that affect bytes MUST be recorded in `policies.membership_filter` including (as applicable):
- seed
- bits-per-key / fpp target
- fingerprint size / load factor
- hash function count

7.2 If the pack includes bitmaps (e.g., Roaring), the bitmap format and any optimization steps that affect bytes MUST be recorded in `policies.bitmap`, including whether run optimization was applied.

7.3 Implementations MUST ensure membership filter and bitmap construction is deterministic (no random seeds unless explicitly recorded).

### 8) File inventory and integrity

8.1 The Runtime Pack Manifest MUST enumerate all files included in the pack under `files[]`, including:
- path
- role
- sha256
- size_bytes

8.2 The set of files and their hashes MUST be sufficient for consumers to verify the pack.

### 9) Runtime Pack ID derivation

9.1 The `runtime_pack_id` MUST be derived from a canonical, deterministic representation of the pack’s hashed material.  
9.2 The hashed material MUST include, at minimum:
- the Runtime Pack Manifest content (excluding signatures) OR a canonical projection of it
- the file inventory with each file’s sha256 and relative path
- the referenced Exchange ID

9.3 The exact hashed material definition MUST be documented and test-vectorized.

### 10) Time, randomness, and environment constraints

10.1 The build MUST NOT incorporate non-deterministic sources (system time, nondeterministic PRNG, thread scheduling) into any bytes that are hashed or part of the pack outputs.  
10.2 `created_at` MAY reflect build time but MUST NOT affect any content-addressed IDs.  
10.3 If parallel compilation is used, the output MUST be equivalent to a deterministic serial order.

### 11) Validation as an acceptance gate

11.1 Runtime Pack compilation MUST depend on a successful deterministic validation step.  
11.2 If validation fails, the compiler MUST NOT produce:
- an Exchange commit, or
- a Runtime Pack that claims v3 conformance.

### 12) Reproducibility acceptance criteria

12.1 A v3 core-conformant build MUST pass the acceptance tests defined in:
`03-reproducibility/reproducibility-acceptance-tests.md`

12.2 At minimum, acceptance testing MUST verify:
- identical inputs + policies → identical output bytes for all pack files
- identical manifests (excluding non-hashed timestamps) and identical file inventories
- stable IDs across independent implementations

## Non-normative notes

- Keeping the policy surface area small is intentional: it encourages comparable builds and reduces ecosystem fragmentation.
- Advanced optimizations (e.g., Parquet bloom filters) should typically be gated behind explicit profiles unless they are proven portable and deterministic across toolchains.
- Operational resilience patterns (circuit breakers, DLQs, blue/green, canary) are described in `08-ops/` and are not part of artifact conformance.

## Open questions (to resolve in v3 finalization)

- Define the exact canonical “hashed material” projection for `runtime_pack_id` (manifest-only vs manifest+file list vs container hash).
- Decide which Parquet knobs are permitted in v3 core vs profile-only.
- Decide whether `lexicographic_sop_asc` and `qid_pid_statement_id_asc` are sufficient ordering policies for core.

===== END 03-reproducibility/deterministic-build-rules.md (#0012) =====

===== BEGIN 03-reproducibility/reproducibility-acceptance-tests.md (#0013) =====
# Reproducibility Acceptance Tests (Kristal v3)

## Status
Draft (normative acceptance criteria)

## Purpose
Define the **acceptance tests** that determine whether a Kristal v3 implementation produces **reproducible** artifacts.

In v3, reproducibility is a first-class requirement:
- Exchange rebuilds MUST produce identical `kristal_id` given the same inputs and rules.
- Runtime Pack rebuilds MUST produce identical `pack_id` (or equivalent) and identical declared payload hashes given the same inputs, compiler, configuration, and policy selections.

These tests are designed to prevent “works on my machine” builds and to ensure artifacts are comparable across toolchains.

## Normative language
The key words **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as normative requirements.

---

# 1. Definitions

## 1.1 Inputs
An **Input Snapshot** is a content-addressed reference to the exact source inputs used for a build (datasets, Claim-IR sets, resolved Claim-IR sets, configuration files, etc.).

## 1.2 Build determinism surface
The determinism surface for a build is defined by:
- the declared input snapshots,
- the compiler identity and version,
- the full build configuration (identified by `config_hash`),
- and the recorded `policy_selections` (see `03-reproducibility/allowed-runtime-pack-policies.md`).

## 1.3 Artifact hashes
- `kristal_id`: content hash of Exchange (signatures excluded).
- `pack_id`: content hash of Runtime Pack (as defined by Runtime Pack contract).
- `payload_hashes`: hashes of pack payload components (Parquet files, index files, etc.), as declared in the pack manifest.

---

# 2. Exchange reproducibility tests (mandatory)

## EX-1: Exchange hash determinism (same toolchain)
**Goal:** Exchange rebuild is byte-stable and ID-stable.

**Given**
- identical input snapshots
- identical compiler version
- identical config hash
- identical canonicalization profile/version

**Then**
- the rebuilt Exchange MUST produce the same `kristal_id`
- and the canonicalized Exchange bytes used for hashing MUST match (byte equality)

**Failure**
- If `kristal_id` differs, build is non-reproducible → FAIL.

---

## EX-2: Exchange hash determinism (cross toolchain)
**Goal:** Independent implementations converge on the same ID.

**Given**
- a published Exchange fixture + expected `kristal_id`
- canonicalization defined as RFC 8785 (JCS)

**Then**
- any v3 core conformant implementation MUST compute the expected `kristal_id`.

**Failure**
- mismatch → FAIL (interop-breaking).

---

## EX-3: Signature envelope invariance
**Goal:** Signature presence does not alter the hashed payload.

**Given**
- an Exchange artifact `E0` without signatures
- a signed Exchange artifact `E1` containing signatures in the signature envelope

**Then**
- the hash input (`exchange_without_signatures`) MUST be identical for `E0` and `E1`
- `kristal_id(E0)` MUST equal `kristal_id(E1)`

**Failure**
- if signatures affect hash input → FAIL.

---

## EX-4: Fail-closed verification (Exchange)
**Goal:** declared integrity cannot be ignored.

**Given**
- an Exchange artifact that declares a hash/signature
- a verifier implementation

**Then**
- verifier MUST error if:
  - signature verification fails
  - declared hash does not match computed hash
  - integrity material is malformed/ambiguous

**Failure**
- verifier continues “best effort” → FAIL.

---

# 3. Runtime Pack reproducibility tests (mandatory)

## RP-1: Pack rebuild determinism (same toolchain)
**Goal:** same inputs → identical pack.

**Given**
- identical input snapshots
- identical compiler identity + version
- identical config hash
- identical policy selections

**Then**
- rebuilt Runtime Pack MUST produce identical:
  - `pack_id`
  - `payload_hashes` (for each payload component)
  - `policy_selections` recorded in manifest

**Failure**
- any mismatch → FAIL.

---

## RP-2: Pack determinism under stable ordering policy
**Goal:** ordering is not implementation-dependent.

**Given**
- a fixed ordering policy (e.g., `ORDER_SET([SPO])`)
- a fixed tie-breaker rule (including `claim_id`)

**Then**
- the triples table ordering MUST be identical between rebuilds
- and consistent across platforms (Windows/Linux/macOS) for the same toolchain.

**Failure**
- any reordering → FAIL.

---

## RP-3: Row-group policy determinism
**Goal:** row-group assignment is deterministic.

**Given**
- a declared row-group policy (e.g., `FIXED_ROWS(500000)`)

**Then**
- the boundaries of row-groups MUST be identical across rebuilds
- and MUST NOT depend on unstable runtime factors (thread scheduling, CPU count, memory pressure)

**Failure**
- row-group boundaries differ → FAIL.

---

## RP-4: Membership filter determinism
**Goal:** filter metadata and behavior are reproducible.

**Given**
- membership filter policy declared (e.g., `BINARY_FUSE`)
- declared parameters (seed(s), bits-per-key, variant, key-space encoding)

**Then**
- the filter construction MUST be identical across rebuilds
- filter metadata recorded in manifest MUST match exactly

**And**
- filter false positives MUST be pruned deterministically against authoritative data

**Failure**
- filter differs under same seeds/params → FAIL.

---

## RP-5: Bitmap determinism (Roaring + run optimization)
**Goal:** bitmap encoding does not drift.

**Given**
- bitmap policy `ROARING`
- run optimization flag ENABLED or DISABLED

**Then**
- emitted bitmap files (or their declared hashes) MUST match across rebuilds.

**Failure**
- mismatch → FAIL.

---

## RP-6: Fail-closed verification (Runtime Pack)
**Goal:** declared integrity cannot be ignored.

**Given**
- a Runtime Pack that declares payload hashes and/or signatures

**Then**
- pack loaders/verifiers MUST error if:
  - any payload hash mismatch occurs
  - any declared signature fails verification
  - integrity fields are malformed/ambiguous

**Failure**
- “load anyway” behavior → FAIL.

---

# 4. Cross-platform reproducibility tests (recommended)

## XP-1: Cross-OS rebuild reproducibility
**Goal:** avoid platform-specific drift.

**Run**
- Build the same inputs/config/policies on at least two OS environments.

**Then**
- Exchange `kristal_id` MUST match.
- Runtime Pack `pack_id` and payload hashes SHOULD match.

**Note**
If exact Runtime Pack bit identity is not feasible cross-OS due to dependency formats, the implementation MUST:
- declare which payload components are excluded from the reproducibility surface, and
- provide a deterministic canonical representation for pack identity.

---

# 5. Performance and resource invariants (recommended)

These are not core determinism requirements, but SHOULD be recorded for operational predictability:
- build wall time
- peak memory
- pack size
- index sizes (bitmaps, filters)

If recorded, these MUST NOT affect core identity unless explicitly included in the declared reproducibility surface.

---

# 6. Test artifacts and fixtures

Implementations MUST provide:
- Exchange fixtures + expected `kristal_id`
- Runtime Pack fixtures + expected `pack_id` + expected payload hashes
- JCS canonicalization vectors + expected hashes
- Query fixtures for stable paging (cursor/offset), join caps, and error modes

See `09-test-vectors/` and `10-examples/`.

---

# 7. Definition of done (reproducibility)

A Kristal v3 implementation passes reproducibility if:
- All Exchange tests EX-1 through EX-4 pass (mandatory).
- All Runtime Pack tests RP-1 through RP-6 pass (mandatory).
- Cross-platform test XP-1 is run for at least one release candidate (recommended).

Failure of any mandatory test blocks release of v3 artifacts.

===== END 03-reproducibility/reproducibility-acceptance-tests.md (#0013) =====

===== BEGIN 04-query/query-contract.md (#0014) =====
# Query contract

## Status

Draft (v3)

## Purpose

This document defines the **offline query contract** for Kristal v3 **Runtime Packs** (and any local wrapper service that exposes them). The goal is a **portable, deterministic, offline-executable** query surface that supports common retrieval needs (search/navigation primitives, constrained graph lookups) without requiring full SPARQL.

This contract is intentionally constrained to preserve offline predictability and reproducibility.

---

## 1. Scope and non-goals

### 1.1 In scope

* A **triple-pattern** query model over `(s, p, o)` with any subset bound/unbound.
* Deterministic result ordering.
* Deterministic paging (cursor or offset).
* Deterministic failure behavior for resource limits (join caps, page caps, timeouts).
* Optional profiles: TPF-like pagination, per-pattern cardinality metadata.

### 1.2 Out of scope (non-goals)

* Full SPARQL 1.1 semantics (OPTIONAL, UNION, FILTER with full expression semantics, property paths, subqueries, federated queries).
* Network dependencies: queries MUST be executable offline over a local Runtime Pack.
* Non-deterministic query behavior (randomization, adaptive sampling without declaring a profile).

---

## 2. Terminology

* **Term**: a subject/object IRI-like identifier (e.g., QID) or literal.
* **Triple**: `(s, p, o)` where `s` and `p` are identifiers; `o` is identifier or literal.
* **Triple pattern**: a triple with any of `s`, `p`, `o` possibly unbound.
* **Binding**: a concrete value for an unbound position.
* **Result set**: ordered list of matching triples or bindings.
* **Cursor**: opaque paging token that resumes iteration deterministically.
* **Offset paging**: deterministic paging by `(offset, limit)` against a deterministic ordering.
* **join1**: a constrained two-stage lookup pattern (see Section 6) with a defined cap.

Normative keywords: MUST, MUST NOT, SHOULD, SHOULD NOT, MAY.

---

## 3. Query model (mandatory)

### 3.1 Supported query primitive

An implementation MUST support querying a single triple pattern:

* Inputs:

  * `s` (bound or unbound)
  * `p` (bound or unbound)
  * `o` (bound or unbound)
  * `limit` (positive integer)
  * paging parameter(s) (cursor or offset mode, see Section 5)

* Output:

  * an ordered sequence of results, each result containing either:

    * matching triples `(s, p, o)`; or
    * bindings for unbound positions (`?s`, `?p`, `?o`) plus (optionally) the full triple

Implementations MUST document which output shape they use and MUST keep it stable within a `query_contract_version`.

### 3.2 Determinism

Given:

* identical Runtime Pack bytes,
* identical portable policy selections recorded in the pack manifest (ordering, etc.),
* identical query inputs,

the implementation MUST return:

* identical result ordering, and
* identical paging behavior.

---

## 4. Data model constraints (mandatory)

### 4.1 Identifiers and literals

* Subjects and properties MUST be represented in a stable identifier space (e.g., QID/PID-like strings or an equivalent stable encoding).
* Literal normalization rules (numbers, dates, language tags) MUST be deterministic and MUST be consistent with the Runtime Pack’s manifest (or a referenced normalization profile).

### 4.2 Rank / “truthy” semantics

Runtime Packs MUST define (in their manifest) whether the runtime query surface:

* returns the full statement set, or
* returns a “truthy/best-rank” projection, or
* supports both as named projections.

If “truthy” is supported, the mapping rules MUST be deterministic and documented. If only exports define truthy behavior and runtime does not, the runtime MUST state that clearly.

---

## 5. Result ordering (mandatory)

### 5.1 Ordering source of truth

Result ordering MUST be derived from the Runtime Pack’s declared ordering policy (e.g., triple-table ordering such as SPO, POS, etc.). The ordering policy MUST be recorded in the Runtime Pack manifest.

### 5.2 Stable tie-breakers

If multiple rows compare equal under the primary ordering keys, implementations MUST define stable tie-breakers (e.g., internal row-id, claim_id) so ordering is total and deterministic.

### 5.3 Ordering disclosure

Implementations MUST document:

* the primary ordering key order,
* tie-breakers,
* whether ordering is over triples, bindings, or both.

---

## 6. Resource limits and join caps (mandatory)

### 6.1 Required limits to declare

Implementations MUST declare, at minimum:

* `page_limit_max` (maximum `limit` accepted),
* `join1_cap` (cap on intermediate expansion for join-like patterns, if supported),
* strictness behavior for cap breaches (see 6.3).

These MUST be surfaced in either:

* the Runtime Pack manifest, or
* the query wrapper configuration (if the wrapper is the enforcement point),
  but MUST remain deterministic for a given pack + configuration.

### 6.2 join1 (optional capability, but deterministic if present)

If the runtime supports a two-stage lookup (common for navigation), it MUST define join1 explicitly, for example:

1. Evaluate pattern A to produce intermediate bindings (bounded by `join1_cap`)
2. Use each binding to evaluate pattern B
3. Combine results deterministically

If join1 is not supported, the implementation MUST reject such requests deterministically.

### 6.3 Cap breach behavior (mandatory to define)

When a cap is exceeded, the implementation MUST choose one deterministic policy and document it:

* **ERROR**: return an error response with a stable error code (recommended for correctness)
* **TRUNCATE**: truncate intermediate results deterministically and return a “truncated” flag + counts

Silently truncating without a flag MUST NOT occur.

---

## 7. Paging contract (mandatory)

An implementation MUST support **either** cursor paging **or** offset paging. It MUST document which mode is supported and keep it stable per `query_contract_version`.

### 7.1 Cursor paging (recommended)

If cursor paging is supported:

* The cursor MUST be opaque to callers.
* The cursor MUST resume iteration deterministically for the same pack and query inputs.
* The cursor MUST become invalid if:

  * the pack changes, or
  * the query parameters change (other than `limit`), unless explicitly supported.

Required response fields:

* `next_cursor` (string or null)
* `has_more` (boolean)

### 7.2 Offset paging (allowed)

If offset paging is supported:

* The implementation MUST define ordering (Section 5) such that `(offset, limit)` is deterministic.
* Responses SHOULD include:

  * `offset`
  * `limit`
  * `total` (optional; if expensive, omit or move to a cardinality profile)

---

## 8. Error model (mandatory)

### 8.1 Stable error codes

Implementations MUST return stable, machine-readable error codes, at minimum for:

* invalid query schema / parameter types
* unsupported query shape
* cap exceeded (if ERROR policy)
* cursor invalid/expired
* internal corruption / integrity failure (if pack verification fails)

### 8.2 Deterministic error behavior

Errors MUST be deterministic for a given:

* pack,
* query input,
* policy configuration.

---

## 9. Optional profile: cardinality metadata

If the **cardinality profile** is enabled, responses MAY include:

* `cardinality` object with:

  * `type`: `"exact"` or `"approx"`
  * `value`: integer
  * `bounds`: optional `{ "lower": int, "upper": int }`
  * `confidence`: optional float in `[0,1]`
  * `scope`: e.g., `"pattern"` or `"pattern+projection"`

Rules:

* If `type="exact"`, `value` MUST be correct.
* If `type="approx"`, the implementation MUST document approximation method and what the bounds/confidence mean.

---

## 10. Optional profile: TPF-like wrapper (local/offline)

If the **TPF-like pagination profile** is enabled, a local wrapper MAY expose HTTP endpoints (still offline) such as:

* `GET /tpf?subject=...&predicate=...&object=...&limit=...&cursor=...`
* Response includes:

  * `results` (triples/bindings)
  * `next_cursor`
  * `cardinality` (optional, if enabled)
  * `policy` summary (optional echo)

This profile MUST NOT require network access. “HTTP” here means a local loopback or embedded server.

---

## 11. Manifest requirements (mandatory)

The Runtime Pack manifest MUST include, at minimum, the fields necessary to interpret query behavior deterministically, such as:

* `query_contract_version`
* `ordering_policy` (and any tie-breakers if not implied)
* `paging_mode` (`"cursor"` or `"offset"`)
* `page_limit_max`
* `join1_cap` and `join1_cap_policy` (`"ERROR"` or `"TRUNCATE"`)
* projection support (full vs truthy) or explicit statement that truthy is export-only

---

## 12. Conformance tests (mandatory)

A v3 implementation MUST ship fixtures/tests that validate:

* deterministic ordering for a known pack
* stable paging (cursor or offset) across repeated runs
* cap breach behavior matches declared policy
* error codes are stable and correct
* (if enabled) cardinality profile behavior matches documented semantics

---

## 13. Non-normative implementation notes

* Prefer cursor paging over offset for large packs (offset can be expensive).
* Enforce resource limits early to prevent denial-of-service on constrained devices.
* If the pack is signed, verify signatures before answering any queries; treat integrity failure as a hard error.

---

## 14. Open questions

* Do we require a single canonical response shape (triples vs bindings), or allow both with strong versioning?
* Should truthy projection be mandatory in runtime, or only mandatory in exports?
* Should join1 be standardized as a named operation, or remain an implementation capability with a declared cap?

===== END 04-query/query-contract.md (#0014) =====

===== BEGIN 05-profiles/profile-jsonld-export.md (#0015) =====
# JSON-LD export profile (v3)

## Status

Draft (v3 profile)

## Purpose

This document defines the **JSON-LD 1.1 export profile** for Kristal v3.

Goals:

* Provide a **deterministic**, **portable**, and **Wikibase-aligned** JSON-LD representation of Kristal Exchange content.
* Ensure exporters across languages/toolchains produce **byte-stable output** given the same Exchange content and export policy.
* Define clear boundaries between:

  * Kristal Exchange (canonical JSON source of truth), and
  * JSON-LD export (derived projection for interoperability).

This profile is optional, but if enabled, it is conformance-testable.

---

## 1. Scope and non-goals

### 1.1 In scope

* Deterministic JSON-LD 1.1 structure for exporting claims/statements from Exchange.
* Stable `@context` and `@type` usage to enable consistent RDF interpretation.
* Deterministic ordering rules so the export is byte-stable.
* Rules for encoding:

  * entities (QIDs)
  * properties (PIDs)
  * literals (values, datatypes, language tags)
  * qualifiers
  * references/evidence pointers
  * ranks / truthy mapping (as a projection option)

### 1.2 Out of scope

* Defining the Exchange schema itself.
* Runtime Pack query behavior.
* RDF dataset canonicalization / RDF hashing (handled by the RDF integrity profile).

---

## 2. Profile identification (mandatory)

If JSON-LD export is produced, the exporter MUST declare:

* `export_profile_id = "kristal.v3:jsonld-1.1"`
* `export_profile_version = "1"`

The export MUST also record:

* the `kristal_id` (or content_id) of the Exchange source used
* the `canonicalization_profile` used by Exchange (for auditability)

---

## 3. Determinism requirements (mandatory)

### 3.1 Byte-stable export

Given identical Exchange content and export settings, two implementations MUST output identical JSON bytes after applying:

* the canonical JSON serialization rules used for exports (recommended: JCS for export artifacts)
* the deterministic ordering rules in this profile

### 3.2 Ordering rules

Where arrays represent conceptually unordered sets, they MUST be sorted deterministically.

Minimum required ordering:

* Entities: by entity id (lexicographic)
* Statements: by `statement_id` if present; otherwise by `(subject, property, value, qualifiers_hash, references_hash)`
* Qualifiers: by `(property, value)` lexicographic
* References / evidence pointers: by stable `evidence_id` (or equivalent) lexicographic
* Language maps: by language code lexicographic

No field may be emitted in an implementation-dependent order.

### 3.3 Normalization rules

Exporters MUST preserve normalized values produced by validation/resolution:

* do not re-normalize numbers/dates in export
* do not coerce datatypes beyond what is declared in Exchange
* do not “fix” unresolved ambiguity by picking a best guess

---

## 4. JSON-LD structure (normative)

### 4.1 Top-level document shape

The export MUST be a JSON-LD document with:

* `@context`
* one of:

  * `@graph` (recommended), or
  * top-level node array

The exporter MUST choose one shape and keep it stable within `export_profile_version`.

Recommended:

```json
{
  "@context": { ... },
  "@graph": [ ... ]
}
```

### 4.2 Context requirements (mandatory)

The `@context` MUST:

* be stable and versioned
* define compact terms for:

  * entity identifiers
  * property identifiers
  * statement model fields (qualifiers, references, rank, provenance pointers)

Recommended context strategy:

* Use a single canonical context URI per version (e.g., `https://…/kristal/v3/jsonld/context/v1`)
* Include explicit prefix mappings (e.g., `wd:`, `wdt:`, `p:`, `ps:`, `pq:`, `pr:`) if you align directly to Wikidata-style IRIs.

### 4.3 Node identity

Entity nodes MUST have an `@id` that is stable and derived from the entity identifier.

Recommended:

* QID `Q123` maps to `wd:Q123` (or a declared base IRI + `Q123`)

---

## 5. Statement model (Wikibase-aligned)

### 5.1 Representing claims/statements

The export MUST represent statements in a way that can be interpreted as Wikibase-like statements:

For each subject entity:

* properties map to statements
* each statement includes:

  * main value
  * qualifiers
  * references/evidence pointers
  * rank (if available)

Two acceptable approaches:

1. **Direct Wikidata JSON-LD alignment** (use Wikidata IRIs and statement reification patterns)
2. **Kristal-native JSON-LD** with explicit mappings to Wikibase concepts

The exporter MUST choose one approach and declare it in metadata:

* `statement_model = "wikibase-aligned"` or `statement_model = "kristal-native"`

### 5.2 statement_id inclusion

If `statement_id` exists in Exchange, it MUST be included in export and used for determinism.

If it does not exist, exporters MUST compute a deterministic surrogate key for ordering (not as a new canonical ID unless declared by profile).

---

## 6. Literals and datatypes (mandatory)

### 6.1 Typed literals

Typed values MUST be expressed using JSON-LD value objects:

```json
{ "@value": "2020-01-01", "@type": "xsd:date" }
```

### 6.2 Language-tagged strings

Language values MUST be expressed using:

```json
{ "@value": "Bonjour", "@language": "fr" }
```

### 6.3 Entity references

Values that are entities MUST be `@id` references, not strings.

---

## 7. Qualifiers and references (mandatory)

### 7.1 Qualifiers

Qualifiers MUST be represented as a set/array that is deterministically sorted.

### 7.2 References / evidence pointers

References MUST include stable pointers back to Exchange evidence objects.

Minimum requirement:

* include a stable `evidence_id` / `reference_id` and (optionally) a `content_id` hash for the referenced evidence object.

Export MUST NOT embed large raw evidence blobs unless explicitly enabled by an additional profile.

---

## 8. Ranks and truthy projection

### 8.1 Full vs truthy exports

This profile supports two projections:

* **full**: export all statements with rank metadata
* **truthy**: export only the selected “best” statements per property according to a deterministic rule

If `truthy` is supported, the exporter MUST:

* define the rule (e.g., preferred over normal; latest by time qualifier; stable tie-breakers)
* keep it deterministic
* declare which projection is used in export metadata:

  * `projection = "full"` or `projection = "truthy"`

If truthy rules are not implemented, exporters MUST only emit `projection="full"`.

---

## 9. Integrity linkage (recommended)

The JSON-LD export SHOULD include:

* `source_kristal_id`
* `export_content_id` (hash of the export artifact itself, if you content-address exports)

If the system uses signatures:

* the JSON-LD export MAY be signed as a derived artifact, but this is outside the core and should follow the v3 signature rules.

---

## 10. Conformance tests (mandatory for implementations claiming this profile)

An implementation claiming `kristal.v3:jsonld-1.1` MUST provide fixtures that validate:

* deterministic output bytes for a fixed Exchange input
* correct ordering of entities/statements/qualifiers/references
* correct encoding of literals, datatypes, and language tags
* correct `@context` versioning and stability
* (if truthy supported) truthy projection correctness and determinism

---

## 11. Open questions

* Do we standardize a single canonical `@context` URI and term set, or allow multiple contexts with declared mapping?
* Do we require Wikidata-style IRIs, or allow Kristal-native IRIs with mapping tables?
* How strict should truthy rules be (single global rule vs per-property rules declared in profile)?

===== END 05-profiles/profile-jsonld-export.md (#0015) =====

===== BEGIN 05-profiles/profile-provenance-nanopub-provo.md (#0016) =====
# Profile: Provenance Packaging (Nanopublication + PROV-O)

## Status
Draft (Kristal v3 optional standardized profile)

## Purpose
Provide a portable, interoperable way to package **assertions + provenance + publication metadata** for Kristal exports using:
- **Nanopublication structure** (named graphs: Head, Assertion, Provenance, PubInfo)
- **PROV-O** relations for provenance modeling

This profile is **optional** and MUST NOT affect core Kristal identity/hashing unless explicitly declared by a separate integrity profile.

## Scope
This profile defines:
- The required named graphs and minimum required triples for a nanopublication
- How Kristal claim/evidence identifiers map into nanopub/provenance structures
- How to reference source artifacts (Exchange, Runtime Pack) and build metadata
- Interop rules (stable IRIs, deterministic serialization requirements)

Non-scope:
- Defining trust roots, key distribution, or signature algorithms (handled by signing/trust docs)
- Mandating RDF dataset hashing (handled by the RDFC export integrity profile)
- Mandating full PROV completeness beyond the minimal required terms

## Profile identifier
- `profile_id`: `provenance-nanopub-provo`
- `profile_version`: `1.0`

## Inputs
- A **validated** Kristal Exchange artifact (and optionally a Runtime Pack)
- Deterministic export projection (RDF export profile) to which nanopubs refer
- Claim-level identifiers (`claim_id`) and evidence identifiers (`evidence_id`) as produced by the Kristal pipeline

## Outputs
- One or more nanopublications, each expressed as RDF with named graphs:
  - `:Head`
  - `:Assertion`
  - `:Provenance`
  - `:PubInfo`

Recommended serialization:
- N-Quads (preferred for transport and tooling)
- TriG (acceptable)

## Normative requirements

### R1. Graph structure (MUST)
Each nanopublication MUST contain exactly these four named graphs:

1. **Head graph**: links the nanopublication to the other graphs
2. **Assertion graph**: contains the assertion triples
3. **Provenance graph**: contains provenance about the assertion
4. **PubInfo graph**: contains publication metadata (creator, time, software, etc.)

### R2. Stable identifiers (MUST)
Nanopublication and graph IRIs MUST be stable and deterministic for a given claim bundle.

A conforming implementation MUST use one of the following strategies:

**Strategy A (recommended): content-addressed nanopub IRI**
- `np_id = sha256(canonical_representation_of(assertion_bundle))`
- Base IRI: `urn:kristal:np:<np_id>`
- Graph IRIs:  
  - `urn:kristal:np:<np_id>#Head`  
  - `urn:kristal:np:<np_id>#Assertion`  
  - `urn:kristal:np:<np_id>#Provenance`  
  - `urn:kristal:np:<np_id>#PubInfo`

**Strategy B: deterministic hierarchical IRIs**
- Base IRI derived from `kristal_id` + `claim_id` (or statement group id)
- Graph IRIs formed by suffixing `#Head|#Assertion|#Provenance|#PubInfo`

The chosen strategy MUST be declared in the export metadata.

### R3. Assertion mapping (MUST)
The Assertion graph MUST correspond to one of:
- a single Kristal `claim_id`, or
- a deterministic bundle of claims (e.g., all claims for an entity), provided bundling rules are deterministic and recorded.

The Assertion graph MUST contain:
- the RDF triples representing the claim(s) under the selected RDF export profile
- links back to Kristal claim identifiers via `kristal:claimId` (or an equivalent stable predicate)

### R4. Provenance mapping (MUST)
The Provenance graph MUST express:
- at least one provenance link from the assertion to its evidence
- evidence must be identified using deterministic IDs (`evidence_id`) and/or stable source URIs

The minimal requirement is:
- the assertion (or a proxy node for the assertion) `prov:wasDerivedFrom` the evidence node(s)

### R5. Publication info (MUST)
The PubInfo graph MUST include:
- `prov:generatedAtTime` (UTC timestamp)
- `prov:wasAttributedTo` (agent / organization)
- a pointer to the software/tooling version that produced the nanopub

### R6. Deterministic emission (MUST)
Given identical inputs and policy selections, implementations MUST emit byte-stable nanopub datasets under:
- the same serialization format, and
- deterministic ordering rules for triples/quads within each named graph.

Note: this requirement is about deterministic export generation. Hashing the RDF dataset is not required by this profile.

### R7. No changes to core identity (MUST)
Enabling this provenance packaging profile MUST NOT change:
- `kristal_id`
- Exchange `content_hash`
- Runtime Pack content hashes

unless a separate integrity profile explicitly includes these exports in hash coverage.

## Recommended conventions (SHOULD)

### C1. One nanopub per claim (SHOULD)
Default behavior SHOULD be **one nanopublication per `claim_id`** for maximal addressability and incremental updates.

### C2. Include pointers to Exchange and build metadata (SHOULD)
PubInfo SHOULD include:
- `kristal:kristalId` (the Exchange id)
- `kristal:buildId`
- compiler identity/version fields

### C3. Use PROV-O consistently (SHOULD)
Use PROV-O terms:
- `prov:Entity` for evidence artifacts
- `prov:Activity` for build steps (extract, resolve, validate, compile)
- `prov:Agent` for organizations/services

## Minimal required triples (templates)

### Head graph (required pattern)
- `np: <npIRI> np:hasAssertion <assertionGraphIRI> .`
- `np: <npIRI> np:hasProvenance <provenanceGraphIRI> .`
- `np: <npIRI> np:hasPublicationInfo <pubInfoGraphIRI> .`

(Exact nanopub predicates depend on chosen nanopub vocabulary; implementation MUST declare vocabulary IRIs in export metadata.)

### Provenance graph (required pattern)
- `<assertionNode> prov:wasDerivedFrom <evidenceNode> .`

### PubInfo graph (required pattern)
- `<npIRI> prov:generatedAtTime "YYYY-MM-DDThh:mm:ssZ"^^xsd:dateTime .`
- `<npIRI> prov:wasAttributedTo <agentIRI> .`
- `<npIRI> kristal:compilerVersion "..." .`

## Interoperability constraints
- Implementations MUST document:
  - which nanopub vocabulary is used (IRIs),
  - the IRI strategy (A or B),
  - bundling rules if bundling is used,
  - the serialization format and ordering rules.

## Failure modes and required behaviors
- If the underlying Exchange fails validation, nanopub emission MUST NOT proceed.
- If an evidence link is missing for a claim and the validator marks it as ERROR, nanopub emission MUST NOT proceed for that claim.
- If an evidence link is missing but marked WARNING, nanopub emission MAY proceed, but MUST include a warning issue in the Validation Report.

## Conformance tests
A conforming implementation MUST provide fixtures demonstrating:
- deterministic nanopub IRI generation (same inputs → same IRIs)
- deterministic dataset emission (same inputs → byte-stable quads)
- correct mapping of claim_id and evidence links into PROV-O relations
- enforcement that this profile does not alter core identity/hashing

## Open questions (to finalize)
- Which nanopub vocabulary will be standardized (or should we support a small allowed set)?
- Should we require one nanopub per claim as a MUST, or keep it as SHOULD?
- Do we allow multiple evidence nodes per claim in provenance, and how do we order them deterministically?

===== END 05-profiles/profile-provenance-nanopub-provo.md (#0016) =====

===== BEGIN 05-profiles/profile-query-tpf-pagination.md (#0017) =====
````md
# Profile: Query (TPF-like pagination)

## Status
Optional standardized profile (Kristal v3)

## Purpose

This profile defines an **offline-friendly, TPF-like pagination contract** for querying Kristal Runtime Packs. The intent is to provide:
- predictable, cacheable, low-bandwidth query behavior
- stable pagination semantics across implementations
- optional cardinality metadata to support planning and UI

This profile does **not** attempt to replicate full SPARQL semantics. Runtime Packs remain intentionally constrained and offline-executable.

## Scope

This profile specifies:
- request/response envelope for paginated queries
- pagination tokens and stability guarantees
- ordering guarantees required for correct pagination
- optional cardinality metadata
- error and fail-closed semantics for declared capabilities

This profile does not specify:
- the full query language (see `04-query/query-contract.md`)
- network transport (HTTP vs local API), except for normative behaviors that must hold regardless of transport

## Conformance

An implementation claims this profile by including `profile-query-tpf-pagination@1` in the Runtime Pack Manifest `profiles[]` and declaring `query_contract` with:
- `supports_pagination = true`

If claimed, the implementation MUST meet the requirements below.

## Terminology

- **Page**: a bounded subset of results from a query.
- **Cursor token**: an opaque token allowing the client to fetch the next page.
- **Stable order**: a total order over the result set that does not change during pagination.

## Normative requirements

### 1) Capability declaration

1.1 A Runtime Pack that claims this profile MUST declare the query contract in the Runtime Pack Manifest:
- `query_contract.contract_id` (non-empty)
- `query_contract.supports_pagination = true`

1.2 If a pack claims this profile and a consumer requests pagination, the implementation MUST provide pagination behavior as specified here.

### 2) Stable ordering is mandatory for pagination

2.1 Paginated queries MUST have a stable total order over results.  
2.2 The order MUST be derived from the Runtime Pack’s recorded `policies.data_ordering`.  
2.3 Implementations MUST NOT paginate over an unstable or implementation-dependent ordering.

If a query’s semantics do not produce a stable order, the implementation MUST reject pagination for that query with an error (see §8).

### 3) Page size

3.1 Implementations MUST support a `page_size` parameter.  
3.2 Implementations SHOULD enforce a maximum page size to protect offline devices; if enforced, the maximum MUST be documented and MUST be discoverable via `capabilities` (see §7).

### 4) Cursor tokens

4.1 Cursor tokens MUST be opaque to clients.  
4.2 Cursor tokens MUST be deterministic for the same (pack_id, query, page_size, cursor_position) and MUST NOT depend on wall-clock time.  
4.3 Cursor tokens MUST be bound to the specific Runtime Pack (`runtime_pack_id`). A token from one pack MUST NOT be valid on another pack.

4.4 Cursor tokens MUST include sufficient information (directly or indirectly) to resume iteration without re-scanning the full dataset, but the mechanism is implementation-defined.

### 5) Pagination API (logical contract)

Regardless of transport, the logical interface MUST accept:

- `query`: a query object defined in `04-query/query-contract.md`
- `page_size`: integer > 0
- `cursor`: optional opaque token

and MUST return:

- `results`: array of result rows/bindings
- `next_cursor`: null or opaque token
- `page_info`: metadata about the page

### 6) Response envelope (normative fields)

A conformant response MUST include:

- `runtime_pack_id`: sha256 hex
- `query_hash`: sha256 hex (hash of canonical query payload; see §6.2)
- `page_size`: integer
- `results`: array
- `next_cursor`: string or null
- `page_info`: object with:
  - `returned`: integer (count of results returned)
  - `has_more`: boolean

#### 6.2 Query hashing (for caching and comparability)

6.2.1 Implementations MUST compute `query_hash = sha256(JCS(query_payload))` where `query_payload` includes:
- the query object
- page_size
- any explicit ordering parameters (if allowed by the base query contract)
- MUST NOT include `cursor`

6.2.2 `query_hash` MUST use the v3 core canonicalization profile (`jcs-rfc8785@1`).

This enables cache keys and comparability across clients and implementations.

### 7) Capabilities discovery

Implementations MUST provide a capabilities object discoverable via:
- an explicit API call, or
- a static file in the Runtime Pack (e.g., `query/capabilities.json`) referenced in `files[]`

Capabilities MUST include at least:
- supported query contract id(s)
- max page size (if enforced)
- whether cardinality estimates are supported

### 8) Cardinality metadata (optional but standardized)

If the implementation supports cardinality estimates, it MUST:
- set `query_contract.supports_cardinality_estimates = true`
- include `cardinality` in responses:

```json
"cardinality": {
  "type": "estimate",
  "value": 12345,
  "confidence": "low|medium|high"
}
````

Rules:

* `value` MUST be a non-negative integer.
* If exact cardinality is available, the implementation MAY use `"type": "exact"` and omit confidence.

If cardinality is not supported, responses MUST NOT include `cardinality`.

### 9) Determinism and snapshot guarantees

9.1 For a given Runtime Pack, pagination MUST be consistent across repeated calls:

* using the same `cursor` token MUST yield the same subsequent results
* tokens MUST remain valid for the lifetime of the pack

9.2 Implementations MUST treat Runtime Packs as immutable snapshots. If the underlying data changes, it MUST be a new pack with a new `runtime_pack_id`.

### 10) Error handling

Errors MUST be structured and MUST include:

* `code`: stable string identifier
* `message`: human-readable message
* `details`: optional object

Required error codes:

* `UNSUPPORTED_PAGINATION` (query type cannot be paginated)
* `INVALID_CURSOR` (token invalid or not bound to this pack)
* `PAGE_SIZE_TOO_LARGE` (exceeds supported maximum)
* `INVALID_QUERY` (does not conform to base query contract)
* `INTERNAL_ERROR` (unexpected failure)

### 11) Fail-closed behavior for declared capability

If a Runtime Pack Manifest claims this profile but the implementation cannot provide correct pagination behavior for a request that falls within the declared capability set, it MUST return an error (not partial/incorrect results).

## Non-normative guidance

* Prefer cursor designs that can resume without full scans (e.g., last-seen key + index position) but keep tokens opaque.
* Keep page_size defaults small for offline/low-memory environments.
* Provide `query_hash` as a first-class cache key for clients (especially Konnaxion PWA caches).

## Example request/response (non-normative)

Request:

```json
{
  "query": { "type": "spo", "s": "Q42", "p": "P31" },
  "page_size": 50
}
```

Response:

```json
{
  "runtime_pack_id": "aaaaaaaa...aaaa",
  "query_hash": "bbbbbbbb...bbbb",
  "page_size": 50,
  "results": [
    { "s": "Q42", "p": "P31", "o": "Q5" }
  ],
  "next_cursor": "opaque-token",
  "page_info": { "returned": 1, "has_more": true }
}
```

## Open questions

* Should the base query contract allow client-specified ordering, or require ordering to always follow `policies.data_ordering`?
* Should cursor tokens be required to be URL-safe for HTTP transports, or left transport-specific?

```
```

===== END 05-profiles/profile-query-tpf-pagination.md (#0017) =====

===== BEGIN 05-profiles/profile-rdf-integrity-rdfc.md (#0018) =====
# Profile: RDF Integrity (RDFC) (Kristal v3)

## Status
Draft

## Purpose
Provide an optional, standardized integrity mechanism for Kristal v3 RDF exports by computing a deterministic `rdf_hash` over a specified RDF projection using an RDF Dataset Canonicalization method and CI gating.

This profile is designed for deployments that need **semantic-web grade export integrity** (independent verifiers can confirm exported RDF content matches the declared hash), while keeping Kristal v3’s normative core small.

## Scope
In scope:
- Canonicalization and hashing of RDF datasets for selected export projections
- CI conformance gating (RDFC test suite subset)
- Resource limits and fail-closed behavior for hash production

Out of scope:
- Kristal core JSON canonicalization and `kristal_id` (handled by v3 core, JCS)
- Runtime Pack hashing (this profile concerns exports, not runtime packs)
- Any requirement that this profile is enabled by default (it is optional)

## Dependencies
This profile depends on at least one deterministic RDF export profile, typically:
- `profile-rdf-wdqs-export` (full or truthy projection)

The export MUST be deterministic and byte-stable per its export profile before this integrity profile is applied.

## Normative keywords
MUST, SHOULD, MAY are used as in RFC 2119.

## Profile activation
An implementation enables this profile by declaring, in its export manifest:
- `profile.id = "rdf-integrity-rdfc"`
- `profile.version = "3.0"`
- `rdfc.algorithm = "RDFC-1.0"` (or later if explicitly listed as supported)
- `rdf_hash.alg = "sha256"`
- `rdf_hash.coverage` (explicitly enumerated projections covered)

## Covered projections (mandatory declaration)
When enabled, the implementation MUST declare exactly which RDF projection(s) are hash-covered.

At minimum, the manifest MUST include:
- `coverage.projection`: `"full"` and/or `"truthy"` (or other declared export projections)
- `coverage.export_profile_id`: e.g., `"rdf-wdqs"`
- `coverage.graphs`: which named graphs are included in the hash (assertion/reference, etc.)
- `coverage.exclusions`: e.g., “metadata graph excluded”, “generated timestamps excluded”

### Projection equivalence rules
Differences between projections (e.g., full vs truthy) MUST NOT be treated as integrity failures unless the profile explicitly requires equivalence.

Each projection’s `rdf_hash` is independently meaningful.

## Canonicalization method
The canonicalization algorithm MUST be an RDF Dataset Canonicalization method compatible with RDFC-1.0 style conformance (e.g., canonical N-Quads output).

Requirements:
- The input MUST be an RDF dataset (not a single graph unless represented as a dataset).
- The canonicalization MUST produce a deterministic canonical N-Quads byte stream (or equivalent canonical form).
- Blank nodes MUST be deterministically canonicalized (or deterministically skolemized before canonicalization, if allowed by the selected algorithm and documented).

The selected canonicalization method and version MUST be recorded in the manifest.

## Hash computation
`rdf_hash.value` MUST be computed as:

- `SHA-256(canonical_rdf_bytes)`

Where:
- `canonical_rdf_bytes` is the canonical output produced by the selected RDFC algorithm
- canonical bytes MUST be treated as a raw byte sequence (no platform-dependent normalization)

Manifest MUST include:
- algorithm identifiers
- canonicalization implementation identifier and version
- the exact export artifact(s) hashed (filenames or logical references)

## Resource limits (mandatory)
Because RDF dataset canonicalization can exhibit worst-case behavior, implementations MUST support resource limits and MUST declare them in the manifest.

Minimum required limit fields:
- `limits.timeout_ms`
- `limits.max_triples` (or dataset size cap)
- `limits.max_blank_nodes` (or equivalent)
- `limits.max_memory_mb` (recommended)

### Limit exceed behavior (fail-closed)
If resource limits are exceeded during canonicalization or hashing:
- The implementation MUST NOT emit a partial `rdf_hash`.
- The implementation MUST emit a structured failure in the export report (see Errors section).
- If the manifest declares that `rdf_hash` is present/required for the artifact, verifiers MUST treat the artifact as invalid (fail-closed).

## CI gating (mandatory when profile enabled)
If this profile is enabled in a build:
- CI MUST gate the canonicalization implementation against a selected subset of the W3C RDFC-1.0 test suite (or equivalent conformance suite declared by the implementation).
- The selected subset MUST be documented (test IDs) and versioned.

The rationale for subset selection (if not full suite) MUST be documented.

## Verification procedure
A verifier checks:
1. The export manifest declares `rdf-integrity-rdfc` profile activation, coverage, and limits.
2. The verifier re-generates (or loads) the RDF export for the declared projection.
3. The verifier canonicalizes the RDF dataset using the declared algorithm.
4. The verifier hashes the canonical bytes with SHA-256.
5. The verifier compares to `rdf_hash.value`.

If mismatch:
- Verification fails (hard failure).

If resource limits prevent verification:
- The verifier MUST report “verification not possible under declared limits”.
- If the artifact declares `rdf_hash` as required, the verifier SHOULD treat it as invalid for high-assurance contexts.

## Manifest fields (recommended shape)
Implementations SHOULD represent profile activation in the export manifest with fields similar to:

- `profiles[]`:
  - `id`
  - `version`
  - `enabled`
  - `params`

Where `params` includes:
- `rdfc.algorithm`
- `rdfc.version`
- `coverage.*`
- `limits.*`
- `rdf_hash.alg`
- `rdf_hash.value`
- `rdf_hash.artifact_ref`

## Error and warning reporting
When enabled, the exporter MUST emit structured issues:
- Errors:
  - `RDFC_CANONICALIZATION_FAILED`
  - `RDFC_LIMIT_EXCEEDED`
  - `RDFC_UNSUPPORTED_DATASET_FEATURE`
  - `RDFC_HASH_MISMATCH` (verification time)
- Warnings:
  - `RDFC_SUBSET_TEST_SUITE` (not full suite)
  - `RDFC_LIMITS_TIGHT` (limits may reduce verifiability)
  - `RDFC_SKOLIZED_BLANK_NODES` (if applicable)

Each issue SHOULD include:
- `message`
- `path` or `artifact_ref`
- `details` object

## Determinism requirements
- If the underlying export is deterministic per its export profile, and the canonicalization algorithm passes CI gating, then `rdf_hash` MUST be stable across runs given identical inputs.
- If determinism is violated (hash changes across identical rebuilds), the build MUST be treated as non-conformant under this profile.

## Conformance
A build is conformant to this profile if:
- coverage boundaries are explicitly declared,
- canonicalization and hashing follow the declared algorithms,
- resource limits are enforced and recorded,
- CI gating is applied when the profile is enabled,
- fail-closed behavior is implemented for declared `rdf_hash`.

## Interactions with other profiles
- **RDF WDQS Export** profile provides the RDF dataset this profile hashes.
- **Provenance (Nanopub + PROV-O)** profile may package similar graphs, but does not substitute for canonical dataset hashing.
- This profile MUST NOT redefine Kristal core identity (`kristal_id`); it only adds export integrity.

===== END 05-profiles/profile-rdf-integrity-rdfc.md (#0018) =====

===== BEGIN 05-profiles/profile-rdf-wdqs-export.md (#0019) =====
# Profile: RDF WDQS Export (Kristal v3)

## Status
Draft

## Purpose
Define a deterministic RDF export profile for Kristal v3 that is compatible with common Wikidata Query Service (WDQS) expectations and downstream RDF tooling, while keeping Kristal’s core identity and offline runtime constraints intact.

This profile specifies:
- what graphs are exported,
- how statements are represented (including qualifiers and references),
- rank/truthy mapping behavior,
- required determinism rules (byte-stability),
- and conformance expectations.

## Scope
In scope:
- RDF dataset shape and serialization requirements
- statement / qualifier / reference modeling
- rank and “truthy/best-rank” projection rules
- deterministic output requirements

Out of scope:
- RDF dataset hashing / canonicalization (handled by the optional **RDF Integrity (RDFC)** profile)
- live SPARQL service behavior (Kristal Runtime Packs remain offline and constrained)
- full WDQS feature parity (this is an export compatibility profile, not a hosted WDQS clone)

## Terminology
- **Item**: Wikibase entity with QID.
- **Property**: Wikibase property with PID.
- **Statement**: a claim about an item using a property and a value, with optional qualifiers, references, and rank.
- **Truthiness**: a projection selecting best-ranked statements for a given (subject, property).

Normative keywords: MUST, SHOULD, MAY.

## Inputs
- Kristal Exchange (canonical source of truth)
- Export configuration selecting:
  - `export_profile = "rdf-wdqs"`
  - `projection = "full" | "truthy"` (see below)
  - optional language preferences for labels (labels are optional in RDF export unless explicitly enabled)

## Outputs
A deterministic RDF dataset serialized as N-Quads (recommended) or Turtle (allowed with additional determinism constraints).

### Required output artifacts
- `export.rdf.nq` (recommended primary)
- `export.manifest.json` (records profile id, version, projection, and determinism settings)

## Dataset structure

### Graphs
The export MUST be a dataset with at least these named graphs:

1. **Assertion graph** (required)
   - Contains statements and their qualifiers and rank.
2. **Reference graph** (required if references exist)
   - Contains reference nodes and reference details.
3. **Metadata graph** (optional)
   - Contains export metadata (build_id, kristal_id, timestamps, profile selection). This graph MUST NOT affect the Kristal core content hash.

Notes:
- If references are present in the source data, a reference graph MUST be emitted.
- If a metadata graph is emitted, it MUST be clearly separated and excluded from any content-hash calculations unless explicitly declared by a profile.

## URI policy (deterministic)
The export MUST define deterministic URI construction for:
- items (QIDs)
- properties (PIDs)
- statement nodes
- reference nodes
- value nodes (where needed)

### Recommended URI scheme (Wikibase-aligned)
- Items: `wd:Q123`
- Direct properties: `wdt:P123`
- Statement properties: `p:P123`
- Statement node: deterministic IRI derived from a stable statement id
- Qualifier properties: `pq:P123`
- Reference properties: `pr:P123`

An implementation MAY use the canonical Wikidata namespace forms, but MUST be consistent and deterministic.

### Statement node identity (critical)
Each exported statement MUST have a stable identifier across runs given identical inputs.

Requirement:
- If the Exchange provides a stable `claim_id`, the statement node SHOULD be derived from it.
- If not, the statement node MUST be derived from a deterministic hash of:
  - subject QID
  - predicate PID
  - normalized object value
  - normalized qualifiers (sorted deterministically)
  - and (optionally) a disambiguator when multiple identical statements exist.

The exact construction MUST be documented and recorded in the export manifest.

## Statement modeling

### Full projection (`projection = "full"`)
The “full” projection MUST emit:
- direct-value triples (`wdt:Pxx`) for the value
- statement node triples (`p:Pxx`) to a statement node
- qualifier triples (`pq:Pxx`) attached to the statement node
- reference triples (`prov:wasDerivedFrom` or Wikibase-style reference linkage) attached to the statement node
- rank representation (see Rank section)

### Truthy projection (`projection = "truthy"`)
The “truthy” projection MUST emit only best-ranked statements per (subject, property) according to rank rules below.

Rules:
- If preferred-rank statements exist for a given (subject, property), only preferred statements are emitted.
- Else, normal-rank statements are emitted.
- Deprecated statements MUST NOT be emitted in truthy projection.
- If multiple statements share the best rank, all best-ranked statements MUST be emitted.

The truthy projection MUST be deterministic given identical inputs.

## Rank rules
Kristal v3’s WDQS export MUST support at least the following ranks:
- `preferred`
- `normal`
- `deprecated`

Rank MUST be represented in a deterministic manner. Acceptable methods include:
- Wikibase-style rank predicates (preferred)
- explicit rank triples using a dedicated predicate in a documented namespace

The method MUST be stated in the export manifest.

## Value modeling
Object values MUST be serialized in a way compatible with WDQS expectations:

- **Item values**: object is another QID node.
- **Strings**: RDF literal, with language tag only where the value is explicitly monolingual.
- **Monolingual text**: literal with language tag.
- **Time**: xsd:dateTime / xsd:date with documented precision handling.
- **Quantity**: numeric literal with unit modeling documented.
- **Coordinates**: WKT literal or dedicated lat/long predicates (documented).
- **URLs**: IRI.

Normalization:
- Values MUST use Kristal’s normalized forms from Exchange (or a documented export normalization step).
- Export normalization must be deterministic and recorded in the export manifest.

## Qualifiers and references
- Qualifiers MUST be emitted as triples attached to the statement node.
- References MUST be emitted as reference nodes; statement nodes MUST link to reference nodes deterministically.

If a statement has multiple references, all MUST be emitted.

## Determinism requirements (mandatory)
The export MUST be byte-stable given identical inputs and the same profile settings.

Minimum requirements:
1. Use a deterministic serializer configuration.
2. Output N-Quads sorted lexicographically by:
   1) graph IRI
   2) subject
   3) predicate
   4) object
3. Ensure stable blank node handling:
   - either avoid blank nodes (preferred), or
   - deterministically skolemize them.

The export manifest MUST record:
- profile id + version
- projection (`full` or `truthy`)
- namespace choices
- statement node identity scheme
- sorting / serialization parameters

## Conformance
An export is conformant to this profile if:
- it emits the required graphs and required modeling for the chosen projection,
- it follows the deterministic URI and statement identity rules,
- it is byte-stable under repeated builds,
- and it records all required parameters in the manifest.

## Recommended tests
- Fixture dataset with known expected N-Quads output.
- Determinism test: same inputs → identical bytes across runs.
- Rank/truthy tests: preferred overrides normal; deprecated excluded from truthy.
- Multi-reference tests: stable ordering of reference emission.

## Interactions with other profiles
- **RDF Integrity (RDFC)** profile (optional): adds `rdf_hash` computation and RDFC CI gating. This WDQS export profile is a prerequisite input for that profile when enabled.
- **Provenance (Nanopub + PROV-O)** profile (optional): may reuse the same statement and reference nodes, but packaging is separate from this export.

===== END 05-profiles/profile-rdf-wdqs-export.md (#0019) =====

===== BEGIN 05-profiles/profile-validation-shacl.md (#0020) =====
# Profile: Validation Reporting (SHACL)

## Status
Draft (Kristal v3 optional standardized profile)

## Purpose
Provide an interoperable **SHACL-based conformance report** for Kristal artifacts that:
- is **machine-consumable**,
- maps cleanly to the Kristal **Validation Report** issue codes/severity, and
- can be used in CI/CD as an optional validation output.

This profile is **optional** and does not change core Kristal identity or hashing.

## Profile identifier
- `profile_id`: `validation-shacl`
- `profile_version`: `1.0`

## Scope
This profile defines:
- required outputs (SHACL shapes + SHACL validation report)
- minimum mapping rules from SHACL results → Kristal validation issues
- determinism requirements for stable reporting

Non-scope:
- choosing a specific SHACL engine implementation
- mandating RDF export integrity hashing (handled by the RDFC profile)
- embedding operational patterns into Exchange/Runtime schemas

## Inputs
- A validated or candidate Kristal Exchange artifact (and/or derived RDF projection) suitable for SHACL checking
- The Kristal v3 core validation outputs (issue codes, locations) for mapping

## Outputs
When enabled, an implementation MUST produce:
1. A SHACL shapes graph (or a stable reference to it)
2. A SHACL validation report graph

Recommended serializations:
- Turtle (for shapes)
- Turtle or N-Quads / TriG (for reports)

## Normative requirements

### R1. Shapes availability (MUST)
Implementations MUST provide one of:
- `shapes_uri`: a stable URI to the SHACL shapes graph, or
- `shapes_inline`: embedded shapes graph (for offline packaging)

The shapes MUST be versioned and the version MUST be recorded.

### R2. Deterministic execution (MUST)
Given identical inputs and the same shapes version:
- the set of reported violations MUST be identical.
- ordering within serializations MUST be deterministic (stable ordering rules).

Note: SHACL engines may differ in ordering; determinism refers to the *set* of results, and deterministic serialization rules must produce byte-stable outputs when the engine output set is the same.

### R3. Required linkage to Kristal validation report (MUST)
The SHACL report MUST be linkable to the Kristal Validation Report via:
- `kristal:kristalId` (or equivalent) and/or `kristal:buildId`
- and MUST declare `profile_id=validation-shacl` in the Validation Report `profiles` list (or equivalent).

### R4. Mapping rules (MUST)
Each SHACL validation result MUST map to a Kristal Validation Report issue:

- `sh:Violation` → `severity = ERROR`
- `sh:Warning` → `severity = WARNING`
- `sh:Info` → `severity = INFO`

And must map to:
- `code`: a stable Kristal issue code
- `message`: a human-readable explanation
- `location`: a JSON pointer (if mapping to JSON) and/or an RDF focus node IRI

### R5. Minimum SHACL result fields (MUST)
Each SHACL result node SHOULD include, and implementations MUST be able to produce, at minimum:
- `sh:focusNode`
- `sh:resultSeverity`
- `sh:sourceShape` or `sh:sourceConstraintComponent`
- `sh:resultMessage`

### R6. No effect on compilation gating unless configured (MUST)
Enabling SHACL output MUST NOT change core gating behavior by itself.
Core gating remains driven by the deterministic Kristal validator.
If a deployment chooses to use SHACL as an additional gate, this MUST be explicitly configured and documented (non-default).

## Recommended conventions (SHOULD)

### C1. Shape naming and versioning (SHOULD)
- Shapes SHOULD use stable IRIs containing:
  - `spec_version`
  - `shape_version`
- Example: `urn:kristal:shapes:v3:exchange:1.0`

### C2. Code system (SHOULD)
Define a code namespace for SHACL-mapped issues:
- `KRS_V3_<CATEGORY>_<NAME>`
Examples:
- `KRS_V3_SCHEMA_MISSING_REQUIRED_FIELD`
- `KRS_V3_EVIDENCE_MISSING`
- `KRS_V3_VALUE_NORMALIZATION_FAILED`

### C3. Include both JSON and RDF pointers where possible (SHOULD)
If the validator can derive a JSON pointer for the corresponding location in Exchange, include it in:
- Kristal Validation Report `location.json_pointer`
- SHACL result message or an extension triple (see below)

## Report structure requirements

### Shapes graph
- MUST contain SHACL shapes (NodeShapes / PropertyShapes)
- MUST declare an explicit version identifier (via `owl:versionInfo` or a Kristal predicate)

### Report graph
- MUST follow SHACL Validation Report structure:
  - `sh:conforms` boolean
  - `sh:result` list of result nodes

## Required extension predicates (recommended)
To improve interop between SHACL outputs and Kristal issue locations, implementations SHOULD emit:
- `kristal:issueCode` on each `sh:ValidationResult`
- `kristal:jsonPointer` on each `sh:ValidationResult` when possible
- `kristal:claimId` / `kristal:evidenceId` when applicable

These extensions must not be required by generic SHACL tools but make downstream automation reliable.

## Failure modes and required behaviors
- If shapes are unavailable or invalid, the system MUST fail the SHACL profile execution and record an ERROR in the Kristal Validation Report (but core validation may still proceed if configured).
- If SHACL execution exceeds configured limits (timeout/memory), the profile MUST fail and record an ERROR with explicit limit information.

## Conformance tests
A conforming implementation MUST provide fixtures demonstrating:
- stable shapes versioning and reproducible report production
- correct severity mapping (Violation/Warning/Info)
- stable mapping to Kristal issue codes
- linkability (kristal_id/build_id present)
- deterministic serialization rules for the chosen format(s)

## Open questions (to finalize)
- Do we standardize a single shapes vocabulary per artifact type (Exchange vs Runtime Pack), or allow multiple named shape sets?
- Do we require engines to output `sh:sourceConstraintComponent` consistently, or treat it as best-effort?

===== END 05-profiles/profile-validation-shacl.md (#0020) =====

===== BEGIN 05-profiles/profile-validation-shex.md (#0021) =====
# Profile: Validation (ShEx)

## Status
Optional standardized profile (Kristal v3)

## Purpose

This profile defines how a Kristal v3 implementation MAY publish **ShEx (Shape Expressions)** artifacts derived from validated Kristal Exchange data to support:
- structural conformance checking by external tooling
- implementer guidance and ecosystem interoperability
- debugging and validation transparency

ShEx outputs are **validation aids**. They do not change the Exchange/Runtime Pack schemas and do not affect content-addressed IDs unless explicitly included in hashed material by a separate profile.

## Scope

This profile specifies:
- required/optional ShEx artifacts
- deterministic generation rules (if artifacts claim determinism)
- packaging and manifest references
- verification and failure semantics when ShEx artifacts are declared

This profile does **not**:
- mandate ShEx as the primary validation mechanism (Kristal validation remains deterministic and schema/rule-driven)
- require ShEx for v3 core conformance
- require specific ShEx engines or toolchains

## Conformance

An implementation claims this profile by including `profile-validation-shex@1` in:
- the Exchange Manifest `profiles[]` (if ShEx is attached to Exchange), and/or
- the Runtime Pack Manifest `profiles[]` (if ShEx is shipped with Runtime Packs)

If an implementation claims this profile, it MUST meet the requirements below.

## Artifacts

### Required artifacts

If this profile is claimed, the implementation MUST provide:

1. **Primary ShEx schema**
   - file: `validation/shex/kristal.shex` (recommended path; any path allowed if referenced in manifest)
   - format: ShExC (`text/shex`) or ShExJ (`application/json`)
   - MUST describe the shapes relevant to the Exchange projection covered by this profile

2. **ShEx metadata descriptor**
   - file: `validation/shex/manifest.json`
   - MUST declare:
     - schema format (ShExC or ShExJ)
     - covered export projection(s)
     - version of the profile (`profile-validation-shex@1`)
     - generation tool info and config hash

### Optional artifacts
- `validation/shex/examples/` (minimal passing/failing examples)
- `validation/shex/mapping.md` (human-readable mapping from Kristal constructs to shapes)
- `validation/shex/reports/` (example validation reports; not normative)

## Coverage and projection rules

ShEx shapes MUST be defined against a **declared RDF projection** of the Exchange. Implementations MUST specify one of:

- **Projection A (WDQS-aligned RDF)**: the RDF projection defined in `05-profiles/profile-rdf-wdqs-export.md`
- **Projection B (JSON-LD RDF mapping)**: the JSON-LD export defined in `05-profiles/profile-jsonld-export.md`, interpreted as RDF
- **Projection C (implementation-defined)**: allowed only if the exact projection is specified in `validation/shex/manifest.json`

The ShEx schema MUST explicitly name which projection(s) it covers.

## Deterministic generation requirements

If the implementation claims deterministic generation for the ShEx artifacts, then:

1. The ShEx schema generation MUST be deterministic given:
   - the same Exchange snapshot
   - the same generation tool version
   - the same generation configuration (captured by a config hash)

2. The ShEx metadata descriptor MUST include:
   - `generator.name`
   - `generator.version`
   - `generator.config_hash` (sha256 hex)
   - `exchange_ref.exchange_id` (sha256 hex)

3. Any ordering within ShExJ output that affects bytes MUST be deterministic (e.g., stable sorting of shapes and predicates).

If deterministic generation is not claimed, the profile MAY still be used, but the metadata MUST set `deterministic=false` and MUST NOT be used as a basis for content-addressed IDs.

## Packaging and manifest references

### If attached to Exchange
- The Exchange Manifest MUST list the ShEx files in its file inventory section (if present), including per-file `sha256`.

### If attached to Runtime Packs
- The Runtime Pack Manifest MUST include the ShEx files in `files[]` with:
  - `role = "metadata"` (or a dedicated role if standardized later)
  - `sha256` and `size_bytes`

## Verification and failure semantics

- If ShEx artifacts are declared in a manifest (Exchange or Runtime Pack) and the consumer is configured to verify package integrity, then:
  - missing ShEx files or hash mismatches MUST cause verification failure (fail-closed)
- ShEx validation execution (running a ShEx engine) is OPTIONAL for consumers and MUST NOT be required for v3 core conformance.

## Minimal `validation/shex/manifest.json` schema (non-normative)

Recommended fields:

```json
{
  "profile": "profile-validation-shex@1",
  "deterministic": true,
  "exchange_ref": { "exchange_id": "..." },
  "projection": {
    "id": "profile-rdf-wdqs-export@1",
    "notes": "Shapes target WDQS-aligned RDF projection."
  },
  "schema": {
    "path": "validation/shex/kristal.shex",
    "format": "ShExC"
  },
  "generator": {
    "name": "kristal-shex-gen",
    "version": "1.0.0",
    "config_hash": "..."
  }
}

===== END 05-profiles/profile-validation-shex.md (#0021) =====

===== BEGIN 06-integration/architect-rendering-contract.md (#0022) =====
# Architect rendering contract (v3 integration)

## Status

Draft (v3 integration contract)

## Purpose

This document defines the **contract between Architect and Kristal v3**.

Architect is the **deterministic renderer**: it produces text (and other publishable outputs) **only from validated Kristal knowledge**, without introducing new facts, and with **complete traceability** from every rendered assertion back to Kristal claim(s) and evidence.

This contract applies to:

* rendering from **Runtime Pack query results**, or
* rendering from **Exchange-derived validated query results** (where the query output is itself a deterministic, signed/verified artifact).

Normative keywords: MUST, MUST NOT, SHOULD, SHOULD NOT, MAY.

---

## 1. Scope and non-goals

### 1.1 In scope

* Inputs Architect is allowed to consume
* Determinism requirements for rendering
* Prohibitions on introducing new facts
* Traceability requirements (claim/evidence mapping)
* Error and refusal behavior
* Multilingual rendering rules and templating boundaries
* Output packaging (text + machine-readable trace map)

### 1.2 Out of scope

* How Kristals are built (Orgo/SenTient pipeline)
* Runtime query engine implementation details
* UI presentation requirements in Konnaxion
* Editorial policy (tone/style) beyond determinism and factuality constraints

---

## 2. Contract overview

Architect rendering is a **pure function** over validated inputs:

* Inputs: validated knowledge + rendering spec
* Output: deterministic text + trace metadata
* No network access required to be correct
* No use of probabilistic sources as factual inputs during rendering

---

## 3. Inputs (mandatory constraints)

### 3.1 Allowed inputs

Architect MUST accept only one of the following input types:

**A) Runtime Pack query result bundle**

* `pack_id` (or pack content ID)
* `pack_manifest` (or manifest reference)
* `query_contract_version`
* `query_results` (ordered results)
* `result_provenance` (optional but recommended: query parameters, cursor chain)

**B) Exchange-derived validated query bundle**

* `source_kristal_id`
* `exchange_manifest` (or reference)
* deterministic query spec
* `query_results` (ordered results)
* validation proof that the results were computed from the referenced Exchange under a declared query contract

Architect MUST reject inputs that:

* are not validation-attested, or
* do not include stable IDs for claims/statements, or
* cannot be traced back to a specific `kristal_id` / pack id.

### 3.2 Required identifiers in input

Inputs MUST include enough identifiers to support traceability:

* `kristal_id` (Exchange) or `pack_id` (Runtime Pack)
* stable identifiers for each asserted fact (preferred: `statement_id`; otherwise a deterministic surrogate)
* stable evidence pointer(s) for each asserted fact (`evidence_id`, `reference_id`, or equivalent)

### 3.3 Rendering request specification (required)

Architect MUST take a rendering request object that includes:

* `render_kind` (e.g., `"article"`, `"snippet"`, `"summary"`, `"qa"`, `"card"`)
* `language` (BCP-47 tag, e.g., `en`, `fr-CA`)
* `audience_profile` (optional; must not change factual content)
* `template_id` (or `render_profile_id`) and version
* `projection` (e.g., `"full"` or `"truthy"`, if supported)
* `constraints` (see Section 4)

---

## 4. Deterministic rendering rules (mandatory)

### 4.1 Determinism requirement

For identical:

* validated input bundle bytes,
* template/profile id + version,
* language,
* rendering parameters,

Architect MUST produce identical outputs (text + trace map), modulo explicitly-declared nondeterministic fields (e.g., timestamps) that are not included in output hashing.

### 4.2 No new facts (hard constraint)

Architect MUST NOT introduce any factual assertion that is not supported by at least one input claim/statement.

This includes:

* numbers, dates, names, causal relationships, superlatives, and categorical claims
* “common knowledge” filler if it asserts new facts (not allowed)
* external enrichment from the network (not allowed for factual claims)

Architect MAY add:

* purely structural text (headings, transitions)
* clearly-marked uncertainty language **only if** the uncertainty is present in the input (e.g., qualifiers, confidence, ambiguity flags)
* non-factual stylistic phrasing that does not add information

### 4.3 Ambiguity preservation

If input contains unresolved ambiguity (multiple candidates, uncertain values), Architect MUST either:

* render the ambiguity explicitly (e.g., “may refer to …”), or
* refuse to render the ambiguous claim as a fact (and record a refusal reason)

Architect MUST NOT silently pick one disambiguation unless the input explicitly declares a resolved selection.

### 4.4 Projection consistency

If the input bundle declares a projection (e.g., `truthy`), Architect MUST:

* render only from that projection, and
* label the output metadata with the projection used.

---

## 5. Output requirements (mandatory)

Architect MUST output a **render bundle** with:

1. `rendered_text` (or structured blocks)
2. `trace_map` (machine-readable)
3. `render_metadata`

### 5.1 render_metadata (required fields)

* `render_kind`
* `language`
* `template_id` and `template_version`
* `source_kristal_id` or `pack_id`
* `query_contract_version` (if from runtime)
* `projection`
* `build_id` (Architect run identifier)
* `created` (timestamp)

### 5.2 trace_map (required fields)

The trace map MUST provide **complete coverage** of factual assertions.

Minimum fields:

* `segments[]`: list of rendered segments with stable segment ids

  * `segment_id`
  * `text_span` (byte offsets or token indices) OR `block_id` (if structured blocks)
  * `assertions[]`

Each assertion MUST include:

* `assertion_id` (stable within the render)
* `support[]`: list of support pointers, each containing:

  * `statement_id` (preferred) OR a deterministic statement pointer (subject/property/value + hashes)
  * `evidence_ids[]` (or reference pointers)
  * `source` (Exchange vs Runtime Pack)
* `confidence` (optional; only if present in input)
* `notes` (optional; must not introduce facts)

### 5.3 Coverage rule (mandatory)

Every factual statement in `rendered_text` MUST have at least one `support[]` entry in `trace_map`.

If a segment cannot be supported, Architect MUST:

* either omit the claim from output, or
* include it only as an explicitly-marked uncertainty statement with trace back to the uncertainty-bearing input, or
* fail the render with a deterministic error.

---

## 6. Validation and refusal behavior (mandatory)

Architect MUST implement deterministic refusal/error codes, including at minimum:

* `UNVERIFIED_INPUT` (input not validated / cannot prove provenance)
* `MISSING_TRACE_IDS` (no stable statement/evidence pointers)
* `AMBIGUOUS_INPUT` (ambiguity cannot be rendered under requested constraints)
* `UNSUPPORTED_RENDER_KIND`
* `PROJECTION_MISMATCH`
* `POLICY_VIOLATION_NEW_FACT_RISK` (attempted output would introduce unsupported fact)

Architect MUST return:

* `status = "ok" | "refused" | "error"`
* `code` (stable string)
* `message` (human-readable)
* `details` (optional structured fields)

---

## 7. Multilingual rendering (mandatory constraints)

### 7.1 Language fidelity

Architect MAY translate labels and explanatory text, but MUST NOT alter factual content.

### 7.2 Localized formatting

Architect MAY apply locale-specific formatting (numbers, dates) **only if** it does not change meaning and the underlying normalized value remains traceable.

### 7.3 Determinism across languages

Rendering in different languages may produce different bytes, but each language output MUST be deterministic given the same inputs and the same template/profile.

---

## 8. Security and offline constraints

* Architect MUST NOT require network calls to produce correct factual output.
* If network calls are used for non-factual assets (fonts, templates), they MUST NOT affect factual assertions.
* If inputs are signed, Architect SHOULD verify signatures (or rely on Orgo/Konnaxion verified delivery), but MUST reject inputs that cannot be proven validated under the deployment’s policy.

---

## 9. Conformance tests (required)

An implementation claiming conformance to this contract MUST provide tests for:

* determinism: same input yields identical render bundle
* trace coverage: every asserted claim has support pointers
* “no new facts”: attempts to inject unsupported facts are refused/error
* ambiguity: ambiguous inputs are rendered explicitly or refused deterministically
* projection handling: truthy/full mismatch triggers deterministic error/refusal

---

## 10. Open questions

* Do we standardize the `trace_map` format as JSON Schema in `02-schemas/` (recommended)?
* Do we require `statement_id` in v3 core, or allow only deterministic pointers until statement_id is mandatory?
* Should Architect output itself be content-addressed and optionally signed as a derived artifact (likely a profile)?

===== END 06-integration/architect-rendering-contract.md (#0022) =====

===== BEGIN 06-integration/konnaxion-distribution-contract.md (#0023) =====
# Konnaxion distribution contract (v3 integration)

## Status

Draft (v3 integration contract)

## Purpose

This document defines the contract for how **Konnaxion** distributes, verifies, caches, and activates **Kristal v3 Runtime Packs** (and associated metadata) for offline/low-bandwidth operation.

Konnaxion’s responsibilities in the ecosystem:

* distribute **versioned offline packages**
* enforce **integrity verification** (signatures/hashes) where declared
* provide **predictable activation/rollback/downgrade behavior**
* surface pack provenance and version metadata to higher-level modules (search, navigation, knowledge delivery, curation)

Normative keywords: MUST, MUST NOT, SHOULD, SHOULD NOT, MAY.

---

## 1. Scope and non-goals

### 1.1 In scope

* Pack packaging format and required metadata
* Trust roots and verification rules (fail-closed)
* Versioning, activation, rollback, downgrade prevention
* Offline caching behavior and storage layout expectations
* Distribution channels (tenant/environment scoped)
* Telemetry and feedback signals (as operational signals, not fact mutation)

### 1.2 Out of scope

* How packs are built (Orgo / compiler)
* How facts are debated/curated (Ekoh/Konsensus/Smart Vote policies)
* Query semantics inside the Runtime Pack (covered by query contract)
* Full device management / MDM integration (deployment-specific)

---

## 2. Artifact types and identifiers

### 2.1 Runtime Pack bundle (mandatory)

A distributable unit MUST include:

* `pack_manifest.json` (mandatory)
* pack payload files (Parquet tables, indexes, filters, dictionaries, etc.)
* optional `signatures` for the manifest and/or bundle
* optional `pack_index.json` (channel-level index; see Section 3)

### 2.2 Required IDs (mandatory)

Each pack bundle MUST be uniquely identified by:

* `pack_id` (content-addressed, preferred) OR a deterministic `pack_content_id`
* `source_kristal_id` (the Exchange kristal_id used to compile the pack)
* `build_id` (compiler build id)
* `pack_version` (see Section 4)

Konnaxion MUST treat `pack_id` as the primary identity if present.

---

## 3. Distribution channel and indexes

### 3.1 Channels (mandatory)

Packs MUST be distributed via **channels** that are scoped at minimum by:

* `tenant_id`
* `environment` (e.g., `prod`, `staging`)
* optional `region` or `audience_segment`

Konnaxion MUST NOT mix trust roots or activation rules across channels unless explicitly configured.

### 3.2 Channel pack index (recommended)

Konnaxion SHOULD consume a signed channel index (example: `pack_index.json`) containing:

* `channel_id`
* `latest` pointer(s)
* `pinned` pointer(s)
* optional `minimum_allowed_version`
* optional `revoked` list
* metadata for delta updates (optional profile)

If present and signed, the index MUST be verified using the channel’s trust roots (fail-closed).

---

## 4. Versioning and activation semantics

### 4.1 Version fields (mandatory)

Konnaxion MUST treat pack versions as structured, not ad hoc strings. Minimum required fields:

* `pack_version` (monotonic within a channel)
* `source_kristal_id` (content lineage)
* `compiler_version`
* `created` timestamp

### 4.2 Activation rule (mandatory)

Konnaxion MUST only activate a pack when:

1. pack bundle integrity is verified (if declared)
2. manifest parses and passes schema validation
3. required files referenced by manifest exist
4. pack is compatible with the client runtime (contract versions match)

Activation MUST be an atomic switch from old pack to new pack (no partial activation).

### 4.3 Downgrade prevention (mandatory)

Konnaxion MUST implement downgrade prevention in at least one deterministic form:

* **Monotonic version rule** (recommended): do not activate a pack with `pack_version` lower than the currently active version for that channel, unless explicitly permitted by policy (e.g., emergency rollback).
* **Revocation-aware rule**: do not activate packs listed as revoked in a verified channel index.

If rollback is permitted, it MUST occur through an explicit rollback action (Section 5), not silently.

---

## 5. Rollback behavior (mandatory)

### 5.1 Rollback modes

Konnaxion MUST support at least one rollback mode:

* **Pinned rollback**: activate a previously pinned known-good pack
* **Last-known-good rollback**: activate the most recent previously active pack that is still present and verified

### 5.2 Rollback triggers (deployment policy)

Rollback MAY be triggered by:

* explicit operator action (recommended)
* verified index updates (e.g., “latest revoked”)
* local runtime health signals (optional profile; e.g., repeated query failures)

Rollback MUST be deterministic given the same trigger event sequence.

---

## 6. Integrity verification (fail-closed)

### 6.1 Verification requirements

If the pack manifest or bundle declares any of:

* signatures
* hashes
* signer identity (`kid`)

then Konnaxion MUST:

* verify them before activation
* fail closed on any verification failure

### 6.2 Trust roots (mandatory)

Konnaxion MUST pin trust roots per channel (tenant/environment), and MUST be able to verify offline.

Trust roots MUST NOT be fetched over the network at activation time as a dependency for correctness; they must be pre-provisioned or cached securely.

### 6.3 Verification scope (recommended)

Recommended verification order:

1. verify channel index (if used)
2. verify pack manifest signature(s)
3. verify bundle file hashes referenced by manifest (optional profile; can be expensive)
4. only then activate

---

## 7. Offline caching and storage contract

### 7.1 Storage layout (recommended)

Konnaxion SHOULD store packs in a layout that supports:

* multiple installed versions per channel
* atomic activation
* garbage collection with pinning rules

Example layout:

* `/<tenant>/<env>/<channel>/packs/<pack_id>/...`
* `/<tenant>/<env>/<channel>/active -> <pack_id>`

### 7.2 Cache policy (mandatory to define)

Konnaxion MUST define deterministic cache policies:

* max disk usage per channel
* eviction policy (e.g., LRU with pinned exceptions)
* minimum set of pinned packs to retain (e.g., active + last-known-good)

### 7.3 Low-bandwidth / offline behavior (mandatory)

If offline, Konnaxion MUST:

* continue serving from the active pack
* not attempt activation requiring network-dependent trust roots
* surface “stale pack” metadata (optional UX requirement)

---

## 8. Compatibility checks (mandatory)

Before activation, Konnaxion MUST verify:

* `query_contract_version` supported by the client runtime
* policy selections are supported (or the pack is rejected deterministically)
* required projections/data are present for the consuming module(s) (e.g., if a module requires truthy projection)

If incompatible:

* do not activate
* emit a deterministic error code and diagnostic payload

---

## 9. Telemetry and feedback signals (non-mutating)

Konnaxion MAY emit operational signals to Orgo such as:

* download/verification failures
* activation success/failure
* query runtime errors and performance summaries
* pack usage metrics (counts, not raw facts)

These signals MUST NOT mutate Kristal Exchange directly; they should create Cases/Tasks or distribution adjustments.

---

## 10. Conformance tests (required)

A Konnaxion implementation claiming conformance MUST provide tests for:

* signature verification success/failure (fail-closed)
* atomic activation and no partial state
* downgrade prevention behavior
* rollback behavior and determinism
* offline behavior (serve active pack; no network dependency for correctness)
* cache eviction respects pinned packs

---

## 11. Open questions

* Do we require bundle-level file hashing in core, or keep it as a profile due to cost?
* Do we standardize delta update manifests for packs (likely a profile)?
* How do we represent revocation lists (index vs separate signed document)?

===== END 06-integration/konnaxion-distribution-contract.md (#0023) =====

===== BEGIN 06-integration/orgo-workflow-contract.md (#0024) =====
# Orgo Workflow Contract (Kristal v3 Integration)

## Status
Draft (normative integration contract)

## Purpose
Define the required **workflow orchestration**, **governance**, and **auditability** behavior for Orgo when Orgo acts as the control plane for Kristal v3 production and distribution.

This contract is concerned with:
- enforcing **pipeline ordering** (ingest → Claim-IR → resolution → validation → publish),
- enforcing **deterministic acceptance gates** (“no compile on fail”),
- ensuring every build is **reproducible** (inputs, config, policy selections recorded),
- and ensuring production/distribution actions are **auditable** and tenant-safe.

This document does **not** define the internal Orgo task model beyond what is necessary for Kristal interoperability.

## Normative language
The key words **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as normative requirements.

---

# 1. Roles and responsibilities

## 1.1 Orgo is the workflow control plane
Orgo MUST:
- create and manage the lifecycle of Kristal build workflows,
- store workflow state, approvals, and audit logs,
- record build inputs/outputs and their content-addressed identifiers,
- trigger distribution and track distribution status,
- surface deterministic errors/warnings to operators.

Orgo MUST NOT:
- mutate Kristal Exchange artifacts directly as a result of feedback signals,
- bypass deterministic validation gates.

## 1.2 Pipeline systems referenced by Orgo
Orgo orchestrates interactions with:
- Extractors (LLMs / classical / hybrid) that output Claim-IR only
- SenTient for resolution (Resolved Claim-IR)
- Validation engine (deterministic)
- Kristal compiler for Exchange and Runtime Pack creation
- Distribution systems (e.g., Konnaxion package distribution)

---

# 2. Workflow stages (mandatory)

A Kristal build workflow MUST follow this stage order:

1. **Ingest**
2. **Extract → Claim-IR**
3. **Resolve (SenTient) → Resolved Claim-IR**
4. **Validate**
5. **Compile → Exchange**
6. **Compile → Runtime Pack**
7. **Publish/Distribute**
8. **Post-publish verification (recommended)**

Orgo MAY split stages into sub-stages, but MUST preserve the ordering constraints and gating semantics in Section 3.

---

# 3. Gating and determinism (mandatory)

## 3.1 “No compile on fail” (hard gate)
If validation fails:
- Orgo MUST mark the workflow as failed at the Validation stage.
- Orgo MUST NOT invoke Exchange or Runtime Pack compilation.
- Orgo MUST surface the validation report (structured codes + messages) to operators.

## 3.2 Deterministic stage outputs
For each stage, Orgo MUST record the content-addressed references to outputs, including:
- Claim-IR batch IDs
- Resolved Claim-IR batch IDs
- Validation report IDs
- Exchange `kristal_id`
- Runtime Pack `pack_id` and payload hashes

## 3.3 Idempotency and replay
Orgo SHOULD support deterministic replay:
- Given the same input snapshots and build configuration, re-running a stage SHOULD yield the same outputs (subject to probabilistic extractors being frozen or replaced with stored Claim-IR).

Orgo MUST ensure that replay does not bypass integrity checks.

---

# 4. Build record requirements (mandatory)

For every Kristal build, Orgo MUST persist a **Build Record** containing:

## 4.1 Identifiers
- `build_id` (unique)
- `tenant_id` (mandatory in multi-tenant deployments)
- `workflow_id` / `case_id` (link back to Orgo case/task)

## 4.2 Inputs (snapshots)
- `input_snapshots[]`: content-addressed references to all inputs used
  - source dataset snapshots
  - Claim-IR snapshots (if extraction is external/frozen)
  - configuration snapshots

## 4.3 Compiler identity and config hash
- `compiler.name`
- `compiler.version`
- `config_hash` (hash of full build config)
- `canonicalization_profile` + `canonicalization_version`

## 4.4 Policy selections (portable policies)
- `policy_selections` as defined in:
  - `03-reproducibility/allowed-runtime-pack-policies.md`

## 4.5 Outputs
- Exchange output:
  - `kristal_id`
  - declared hashes and/or signatures
- Runtime Pack output:
  - `pack_id`
  - payload hashes
  - manifest hash/signature references

## 4.6 Validation summary
- `validation_status` in `{PASS, FAIL}`
- `validation_codes[]` (stable machine codes)
- `validation_report_ref` (content-addressed reference)

---

# 5. Integrity verification requirements (mandatory)

## 5.1 Pre-publish verification
Before publishing/distributing Exchange or Runtime Pack artifacts, Orgo MUST verify:
- declared content hashes match computed hashes
- declared signatures verify (if present)

If verification fails, Orgo MUST:
- fail the workflow,
- prevent publish/distribution,
- record the failure reason.

## 5.2 Fail-closed behavior
Orgo MUST enforce fail-closed behavior for declared integrity material:
- Orgo MUST NOT “publish anyway” when verification fails.
- Orgo MUST treat malformed integrity fields as errors.

---

# 6. Distribution workflow requirements (mandatory)

## 6.1 Versioned release objects
Orgo MUST create a **Release** record per published version containing:
- release ID/version
- Exchange `kristal_id` reference(s)
- Runtime Pack `pack_id` reference(s)
- target channels (tenants, regions, device cohorts)
- publish timestamp
- verification status

## 6.2 Rollout controls (recommended)
Orgo SHOULD support progressive rollout strategies:
- staged rollouts by cohort
- canary or blue/green releases
- automatic rollback on verification failures or high error rates

These rollout mechanics are operational guidance (not schema-level requirements), but the **release record** MUST be auditable.

## 6.3 Downgrade prevention (mandatory where applicable)
If the distribution environment supports version pinning:
- Orgo MUST provide a mechanism to prevent downgrade to a vulnerable/invalid pack version.
- Orgo MUST record pinned minimum versions per channel.

(See `07-security/downgrade-rollback-policy.md`.)

---

# 7. Multi-tenancy and isolation (mandatory)

## 7.1 Tenant scoping
All workflow records MUST be tenant-scoped:
- Orgo MUST prevent cross-tenant visibility of build inputs/outputs unless explicitly configured for shared artifacts.

## 7.2 Keys and signing
Signing keys MAY be tenant-scoped even if `kristal_id` is global content-addressed.
Orgo MUST:
- record which key(s) signed which release,
- enforce that verification uses the correct trust roots for the tenant/channel.

(See `07-security/key-management-and-trust-roots.md`.)

---

# 8. Feedback loop handling (mandatory)

## 8.1 Feedback must not mutate Exchange directly
Orgo MUST represent feedback as:
- new Cases/Tasks that trigger a new build cycle, or
- structured signals that lead to new Claim-IR proposals.

Orgo MUST NOT:
- edit Exchange artifacts in-place due to votes/curation/user edits.

## 8.2 Provenance linkage (recommended)
Orgo SHOULD link:
- feedback signals → cases/tasks → resulting builds/releases,
to make governance auditable.

---

# 9. Observability requirements (recommended)

Orgo SHOULD emit structured logs/events for each stage with correlation identifiers:
- `build_id`
- `tenant_id`
- `kristal_id`
- `pack_id`
- stage name + outcome
- validation error codes
- signature verification result

(See `08-ops/logging-and-correlation-ids.md`.)

---

# 10. Minimal API surface (informative)

Orgo implementations typically expose:
- `CreateBuildWorkflow(input_snapshots, config_ref, policy_selections)`
- `AdvanceStage(build_id, stage, outputs...)`
- `GetBuildRecord(build_id)`
- `CreateRelease(build_id, channels...)`
- `GetReleaseStatus(release_id)`

This section is informative; API shape is implementation-specific.

---

# 11. Conformance checklist (Orgo)

Orgo satisfies this contract if it:
- enforces stage ordering and “no compile on validation failure”,
- records build inputs/config/policies/outputs in auditable Build Records,
- verifies hashes/signatures before publish and fails closed on mismatch,
- creates auditable versioned Release records,
- isolates multi-tenant workflows and enforces correct trust roots,
- ensures feedback triggers new build cycles rather than in-place edits.

===== END 06-integration/orgo-workflow-contract.md (#0024) =====

===== BEGIN 06-integration/sentient-resolution-contract.md (#0025) =====
# SenTient Resolution Contract (Kristal v3 Integration)

## Status
Draft (normative integration contract)

## Purpose
Define the required **inputs**, **outputs**, and **deterministic semantics** for SenTient when SenTient acts as the reconciliation / resolution engine in the Kristal v3 pipeline.

This contract ensures:
- ambiguity is preserved explicitly (no silent coercion),
- outputs are schema-valid and deterministically structured,
- downstream validation/compilation remains reproducible and auditable,
- failure modes are explicit and do not block the pipeline indefinitely.

This document does **not** prescribe SenTient’s internal retrieval/scoring/judging architecture. It specifies the interoperability boundary only.

## Normative language
The key words **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as normative requirements.

---

# 1. SenTient role in the Kristal pipeline

SenTient is responsible for converting Claim-IR’s surface forms and provisional values into:
- ranked candidate identifiers (QIDs/PIDs),
- normalized typed literals,
- explicit unresolved ambiguity structures,
- structured warnings/errors.

SenTient MUST NOT:
- force disambiguation without evidence,
- silently coerce ambiguous surfaces into single IDs,
- introduce new claims beyond what Claim-IR proposes.

---

# 2. Inputs (mandatory)

## 2.1 Primary input: Claim-IR batch
SenTient MUST accept as primary input:
- a **Claim-IR batch** conforming to `02-schemas/claim-ir.schema.json`.

The input MUST include (at minimum):
- `claim_id` (or stable local ID)
- surface forms for entities/properties
- proposed literals/values (where applicable)
- evidence pointers (documents/snippets/datasets)
- uncertainty representation (confidence / distribution / modality as defined by Claim-IR)

## 2.2 Optional input: hints and constraints
SenTient MAY accept optional hints, such as:
- preferred language/locale
- candidate constraints (allowed QID/PID sets)
- tenant-specific mapping overlays
- prior resolution state (for incremental resolution)

If hints are used, SenTient MUST:
- treat them as advisory,
- record their presence in the output metadata (see Section 5).

---

# 3. Outputs (mandatory)

## 3.1 Primary output: Resolved Claim-IR batch
SenTient MUST output a **Resolved Claim-IR** batch conforming to:
- `02-schemas/resolved-claim-ir.schema.json`

The output MUST preserve a stable mapping to inputs:
- every output resolution result MUST reference the originating `claim_id`.

## 3.2 Resolution results per surface
For each resolvable surface (entity surface, property surface, value normalization target), SenTient MUST provide:

### A) Ranked candidates
- `candidates[]` sorted by decreasing score
- each candidate includes:
  - `id` (QID or PID)
  - `score` (numeric, comparable)
  - `evidence` (support evidence pointers or feature justification refs)
  - optional `features` (informative)

### B) Decision state
One of the following MUST be explicitly recorded:

- `RESOLVED_SINGLE` (resolved to one best candidate)
- `RESOLVED_MULTI` (multiple candidates remain plausible; not forced)
- `UNRESOLVED` (no adequate candidate)
- `ERROR` (resolution process failed in a defined way)

### C) Selected binding (only if resolved)
If in `RESOLVED_SINGLE`, SenTient MUST provide:
- `selected.id` (QID/PID)
- `selected.score`

If in `RESOLVED_MULTI`, SenTient MUST provide:
- `selected` MUST be absent
- `candidates[]` MUST remain present and complete (at least top-K; see Section 4.2)

---

# 4. Determinism and portability requirements (mandatory)

## 4.1 Output structure determinism
SenTient output MUST be deterministic in structure:
- stable field naming and typing,
- stable sorting rules,
- stable serialization order when canonicalized (JCS is applied downstream, but structure must not be nondeterministic).

This does not require the *scores* to be identical across versions; it requires that:
- the output is well-formed,
- candidate ranking is explicit,
- ambiguity is explicit,
- and the same scoring run produces stable ordering rules.

## 4.2 Candidate list truncation (top-K)
If SenTient returns only top-K candidates, then:
- K MUST be declared in output metadata, and
- truncation MUST be consistent by surface type.

A default policy SHOULD be defined (e.g., K=20 for entities, K=10 for properties), but the exact values are implementation-defined.

## 4.3 Stable sorting rules
SenTient MUST define deterministic tie-breakers for candidates:
- primary: score descending
- tie-breaker: stable ID ordering (lexicographic QID/PID)
- final: deterministic hash of (surface, candidate ID) if needed

This avoids nondeterminism when scores collide.

## 4.4 Literal normalization determinism
When normalizing literals (dates, quantities, coordinates, identifiers), SenTient MUST:
- produce typed outputs in a deterministic schema form,
- include explicit unit/precision fields when relevant,
- record any lossy normalization decisions as warnings (see Section 6).

---

# 5. Output metadata (mandatory)

Resolved Claim-IR output MUST include metadata sufficient for downstream validation and auditing:

## 5.1 Required metadata
- `resolution_run_id` (unique)
- `sentient_version` (resolver version string)
- `timestamp` (ISO 8601)
- `input_batch_ref` (content-addressed ref to Claim-IR batch)
- `hints_used` (boolean)
- `hint_refs[]` (if hints_used=true; references to hint payloads)
- `policies` object containing (at minimum):
  - `candidate_top_k` per surface type
  - `tie_breakers` declaration
  - `normalization_ruleset_id` (versioned identifier)

## 5.2 Optional metadata
- resource limits encountered (timeouts, caps)
- corpus snapshot IDs used for candidate generation
- model identifiers used for semantic scoring (if any)

If optional metadata is recorded, it MUST NOT affect core identity unless explicitly included in the declared reproducibility surface.

---

# 6. Warnings and errors (mandatory)

## 6.1 Structured codes
SenTient MUST emit warnings/errors as:
- machine-readable `code`
- severity `{INFO, WARNING, ERROR}`
- human-readable `message`
- optional `details` payload
- `claim_id` linkage where applicable

Codes MUST be stable across minor versions.

## 6.2 Required warning categories (minimum)
SenTient SHOULD include warning codes for:
- unresolved entity/property surfaces
- ambiguous multi-candidate surfaces
- literal normalization losses (rounding, unit coercion, truncation)
- evidence insufficiency / weak grounding
- resource limit truncations (top-K truncation, timeouts)

## 6.3 Failure behavior (mandatory)
If SenTient cannot complete resolution for a claim due to transient issues (timeouts, upstream outages):
- SenTient MUST return a syntactically valid Resolved Claim-IR,
- mark affected surfaces as `UNRESOLVED` or `ERROR`,
- emit explicit error codes,
- and MUST NOT silently drop claims.

---

# 7. Preservation of ambiguity (mandatory)

SenTient MUST preserve unresolved ambiguity rather than forcing a single interpretation:
- If evidence is insufficient for a unique resolution, SenTient MUST use `RESOLVED_MULTI` or `UNRESOLVED`.
- Downstream validation MAY reject certain unresolved forms depending on rules, but SenTient must not hide ambiguity.

---

# 8. Interaction with Validation (contract coupling)

The Validation stage MUST be able to:
- deterministically accept or reject Resolved Claim-IR based on declared rules.

Therefore SenTient MUST:
- keep all resolution states explicit,
- keep all warning/error codes stable and structured,
- provide all required metadata needed to interpret results.

---

# 9. Security and multi-tenancy (mandatory where applicable)

## 9.1 Tenant scoping
If SenTient is used in a multi-tenant environment:
- tenant-specific hint overlays MUST be isolated by tenant_id,
- output metadata MUST indicate tenant scope if applicable.

## 9.2 Input confidentiality
SenTient MUST NOT leak evidence pointers or internal corpora references across tenants.

(Operational enforcement is system-specific; this is a boundary requirement.)

---

# 10. Conformance checklist (SenTient)

SenTient satisfies this contract if it:
- accepts Claim-IR and produces schema-valid Resolved Claim-IR,
- emits ranked candidates and explicit decision states,
- preserves ambiguity (no silent coercion),
- applies deterministic sorting and tie-breakers,
- produces deterministic literal normalization structures,
- emits structured warnings/errors with stable codes,
- returns valid outputs even on partial failure (no dropped claims).

===== END 06-integration/sentient-resolution-contract.md (#0025) =====

===== BEGIN 07-security/downgrade-rollback-policy.md (#0026) =====
# Downgrade and Rollback Policy (Kristal v3)

## Status
Draft

## Purpose
Define how Kristal v3 distributors and clients (notably Konnaxion offline package consumers and Orgo-controlled distribution flows) prevent:
- **downgrade attacks** (maliciously providing an older, vulnerable, or compromised artifact), and
- unsafe **rollbacks** (unintended reversion to older packs due to caching, sync conflicts, or operator error).

This policy is required to make signed Runtime Packs and Exchange releases safe to distribute at scale, especially in offline or intermittently connected environments.

## Scope
In scope:
- Versioning and monotonic update rules for Runtime Packs and Exchange releases
- Minimum metadata required to enforce rollback prevention
- Client enforcement behavior (accept/reject/hold)
- Offline-friendly mechanisms (no reliance on live services)
- Recovery paths (planned rollback, emergency rollback)

Out of scope:
- Key management and revocation mechanics (covered in key-management doc)
- Full content trust model beyond signature verification (covered elsewhere)
- UI/UX specifics (implementation-specific)

## Normative keywords
MUST, SHOULD, MAY as in RFC 2119.

## Core concepts

### Artifact types
- **Exchange release**: canonical, content-addressed, auditable reference.
- **Runtime Pack**: derived, offline-executable distribution payload.

Rollback/downgrade policies apply most critically to Runtime Packs, but SHOULD also apply to Exchange release pointers (e.g., “latest”).

### Threat model (minimum)
This policy defends against:
- A malicious distributor or compromised mirror serving old artifacts.
- A network attacker replaying older signed artifacts.
- Offline caches or sync conflicts reactivating older packs.
- Operator mistakes pushing the wrong version to a region.

This policy assumes:
- Signature verification exists and is fail-closed when present.
- Trust roots are pinned.
- Revocation lists may or may not be available offline (policy must handle both).

## Required metadata for enforcement
Artifacts intended for distribution MUST include, in their manifest (or a distribution index manifest):

1. **artifact_id**
   - Content-addressed id (e.g., `kristal_id` or pack id).
2. **artifact_type**
   - `exchange` or `runtime_pack`.
3. **release_id** (monotonic)
   - A monotonically increasing identifier (see below).
4. **build_id**
   - Unique id for build lineage and audit.
5. **created_at**
   - Timestamp for debugging/audit (not used alone for monotonicity).
6. **channel**
   - Distribution channel identifier (e.g., `prod`, `region-ca-qc`, `tenant-x-prod`).
7. **signer_key_id**
   - The signing key identifier.
8. **parent_release_ids** (recommended)
   - For lineage/merge cases (optional but useful).
9. **revocation_epoch** (recommended)
   - A small integer that increments whenever revocation policy changes materially (e.g., key compromise event).

### Monotonic release_id formats
An implementation MUST choose one monotonic scheme and enforce it consistently per channel.

Allowed schemes:
- **Integer sequence**: `release_id = 10293` (recommended).
- **Semantic version**: `v3.1.4` with strict ordering rules (harder operationally).
- **Hybrid**: integer sequence + human label.

Requirement:
- Comparison MUST be deterministic and documented.

## Distribution index (“what to install”)
Clients SHOULD not rely on “latest” pointers embedded in artifacts alone. Instead, they SHOULD consume a signed **distribution index** per channel.

A distribution index MUST include:
- channel id
- current release_id
- current artifact_id
- optional staged releases (canary)
- signature and signer identity

This index is the primary control point for controlled rollout and rollback.

## Client enforcement rules (mandatory)

### 1) Basic rule: never activate a lower release_id
A client MUST NOT activate an artifact with a lower `release_id` than the highest previously activated release in the same channel, unless a **policy-authorized rollback** is present (see below).

Clients MUST persist:
- `highest_activated_release_id[channel]`
- `highest_seen_release_id[channel]` (recommended)
- last successful verification metadata

### 2) Signature verification first
Before comparing release_ids, clients MUST:
- verify the signature chain to a pinned trust root (when signatures are present)
- verify integrity fields fail-closed
- consult revocations if policy requires and data is available

If verification fails:
- the artifact MUST be rejected regardless of release_id.

### 3) Channel isolation
Rollback and downgrade decisions MUST be scoped by channel.
Example:
- `tenantA-prod` is independent from `tenantA-staging`.

### 4) Handling “equal release_id”
If a client receives an artifact with the same `release_id` but different `artifact_id`:
- The client MUST treat this as a hard error unless an explicit **reissue flag** is present in the signed distribution index.
- This prevents silent substitution attacks.

## Policy-authorized rollback (controlled rollback)
Rollbacks are sometimes necessary (bad pack release). They must be explicit and signed.

### Rollback authorization artifact
A rollback MUST be authorized by a signed “rollback authorization” record, either embedded in the distribution index or distributed alongside it, containing:

- channel id
- `authorized_rollback_to_release_id`
- `reason` (string)
- `issued_at`
- `expires_at` (recommended)
- signature by an authority key (root or intermediate)

Clients MUST:
- verify authorization signature
- ensure the authorization is within validity window
- ensure rollback target is not revoked/blocked by policy
- record that rollback occurred (audit)

### Rollback activation rules
When rollback authorization is present:
- clients MAY activate the rollback target release_id even if lower than previously activated
- but MUST update local state to:
  - keep `highest_seen_release_id` unchanged (so the client remembers newer releases exist)
  - record `current_active_release_id` separately from `highest_activated_release_id` (recommended)

This enables recovery and prevents oscillation.

## Emergency rollback for compromise response
If a key compromise occurs, a rollback may be used to move to a “safe older” release, but only if:
- the older release was signed by non-compromised keys (or is otherwise still trusted), and
- revocation policy does not invalidate it.

In compromise scenarios, clients SHOULD prefer:
- a reissued pack at the same release_id with a reissue flag (if allowed), or
- a new higher release_id that contains the rollback fix.

## Offline and sync edge cases

### Offline clients without index updates
If a client is offline and only has cached artifacts:
- it MUST NOT activate a lower release_id than previously active in that channel unless rollback authorization is cached and valid.
- if only an older artifact is available and no valid rollback authorization exists, the client SHOULD enter a “hold” state rather than silently downgrade.

### Sync conflicts (multi-device / multi-node)
When Orgo/Konnaxion sync introduces conflicting “current” pointers:
- The client MUST choose the highest valid release_id according to channel rules, unless rollback authorization exists.
- Conflicts SHOULD be logged with correlation ids.

## Operational rollout patterns (recommended)
- **Canary releases**: distribution index lists canary cohorts and their current release_id.
- **Blue/green**: clients have active+standby pack slots; activation only occurs after verification.
- **Staged rollouts**: progressively advance `current release_id` in the signed index.

## Logging and observability (recommended)
Clients and distributors SHOULD emit structured events:
- `PACK_VERIFIED` (artifact_id, release_id, signer_key_id)
- `PACK_REJECTED` (reason: verification_failed | downgrade_blocked | revoked_key | index_signature_failed)
- `DOWNGRADE_BLOCKED`
- `ROLLBACK_AUTH_ACCEPTED`
- `ROLLBACK_AUTH_REJECTED`
- `PACK_ACTIVATED` (active_release_id, highest_seen_release_id)

Include: build_id, channel, tenant, device/node id.

## Minimum acceptance criteria
A deployment satisfies this policy if:
1. Clients persist per-channel highest release_id and block downgrades.
2. Rollbacks require an explicit signed authorization record.
3. “Same release_id but different artifact_id” is rejected unless explicitly reissued via signed index.
4. Signature verification is enforced before activation.
5. Offline clients fail safe (hold rather than downgrade silently).

## Open questions (to finalize)
- Whether `release_id` is global per tenant or per channel/region.
- Whether “reissue” is allowed, and which authority can authorize it.
- How long rollback authorizations remain valid in constrained offline environments.
- Whether to require a signed distribution index in all environments (recommended for production).

===== END 07-security/downgrade-rollback-policy.md (#0026) =====

===== BEGIN 07-security/key-management-and-trust-roots.md (#0027) =====
# Key Management and Trust Roots (Kristal v3)

## Status
Draft

## Purpose
Define how Kristal v3 artifacts (Exchange and Runtime Packs) are signed, how trust roots are established, and how verifiers validate signatures in a **fail-closed** manner when integrity declarations are present.

This document is security and operations focused. It does **not** change Kristal’s core content-addressed identity rules; it defines the trust model around distribution and verification.

## Scope
In scope:
- Key types and roles (root, intermediate, signing)
- Trust root pinning models (tenant-scoped and environment-scoped)
- Signature verification requirements for distributors and clients
- Rotation, revocation, and compromise handling
- Minimum manifest fields for signer identity and key metadata

Out of scope:
- Specific cryptographic algorithm choices beyond “supported set” guidance
- Network PKI / CA integration details (may be deployment-specific)
- Secrets storage implementation (HSM/KMS/etc.)—recommended but not mandated

## Normative keywords
MUST, SHOULD, MAY as in RFC 2119.

## Design goals
- **Fail-closed integrity**: if an artifact declares signatures/hashes, verification failures are hard errors.
- **Tenant isolation**: tenants may use independent trust roots and keys.
- **Offline viability**: verification must be possible without network access.
- **Operational safety**: rotation, rollback prevention, and compromise response are first-class.

## Key roles

### 1) Trust Root (Root Key)
A long-lived key that anchors trust for a tenant or environment.

Requirements:
- Trust roots MUST be pin-able (fingerprint) by distributors and clients.
- Trust roots SHOULD be offline or highly protected (HSM/KMS).
- Trust roots SHOULD NOT sign artifacts directly; they should sign intermediates.

### 2) Intermediate / Release Authority Key
A medium-lived key used to sign artifact signing keys or release signing certificates.

Requirements:
- Intermediates MUST be signed by a trust root.
- Intermediates MUST include validity windows.
- Intermediates SHOULD be rotated on a scheduled basis (e.g., quarterly).

### 3) Artifact Signing Key (Pack/Exchange Signing Key)
A shorter-lived key used to sign Exchange commits and Runtime Packs.

Requirements:
- Signing keys MUST be scoped (tenant + environment + artifact type).
- Signing keys SHOULD be rotated regularly (e.g., monthly) and on compromise events.
- Signing keys MUST be auditable (key id, creation, rotation history).

## Trust models

### Model A: Tenant-pinned trust roots (recommended)
Each tenant has its own trust root (or root set). Clients pin the tenant’s root fingerprint(s).

Advantages:
- Strong tenant isolation
- Works offline
- Limits blast radius

### Model B: Environment-pinned trust roots
A deployment pins roots by environment (e.g., dev/stage/prod). Tenants are separated by access control rather than separate roots.

Advantages:
- Simpler operations for small deployments
- Still supports offline verification

Risk:
- Larger blast radius if the root is compromised.

Implementations MUST document which model is used and how pins are distributed.

## Artifact signature requirements

### When signatures are present
If an artifact declares signatures, verifiers MUST:
1. Validate the signature(s) against the artifact’s canonical hashing rules.
2. Validate signer identity and key chain to a pinned trust root.
3. Enforce validity windows.
4. Enforce revocation rules as available offline (see revocation section).

If any step fails, verification MUST fail closed.

### What is signed
The signed payload MUST be the canonical hash of the artifact content:
- Exchange: hash of canonical JSON (JCS), excluding signatures.
- Runtime Pack: hash of the pack manifest’s canonical JSON (JCS) AND (optionally) hashes of referenced files recorded in the manifest.

The signing target MUST be unambiguous and recorded in the manifest.

### Recommended signature envelope fields
Artifacts that are signed SHOULD include a `signatures[]` section in a manifest-like structure with:

- `sig_id`: unique signature id
- `alg`: signature algorithm identifier (e.g., `"ed25519"`, `"rsa-pss-sha256"`)
- `key_id`: signer key identifier
- `signer`: human/organization identifier (string or DID-like)
- `created_at`: timestamp
- `expires_at`: timestamp (optional)
- `payload_hash`: `{ alg: "sha256", value: "<hex>" }`
- `signature`: base64 (or multibase) signature bytes
- `chain`: optional embedded cert/attestation chain (root excluded if pinned externally)

Exact envelope shape is implementation-defined, but all required semantic fields MUST be representable.

## Trust root pinning and distribution

### Pins
A pin is a stable fingerprint of a trust root public key.

Requirements:
- Pins MUST be distributed to clients out-of-band or via a secure bootstrap channel.
- Pins MUST be stored and enforced locally for offline verification.
- Pins SHOULD support multiple active roots to enable rotation.

### Pin sets
Clients and distributors SHOULD support a pin set:
- `active_roots[]`
- `deprecated_roots[]` (accepted for a grace period if allowed by policy)
- `blocked_roots[]` (explicitly rejected)

Policies around acceptance of deprecated roots MUST be documented.

## Key rotation

### Planned rotation
- Trust roots rotate rarely (years) and require careful migration.
- Intermediates rotate periodically (months/quarters).
- Signing keys rotate frequently (weeks/months).

Rotation requirements:
- Rotation MUST support overlap windows (old + new valid simultaneously).
- Clients MUST support multiple pinned roots/intermediates during overlap.
- Artifacts SHOULD record which key id signed them for auditability.

### Emergency rotation (compromise)
On compromise:
- Mark affected key ids as revoked (see revocation).
- Stop issuing new artifacts signed by the compromised key immediately.
- Re-issue current packs signed with new keys.
- Apply downgrade/rollback protections to prevent clients from accepting older compromised artifacts.

## Revocation (offline-friendly)
Because clients may be offline, revocation must work without live OCSP/CRLs.

Recommended approach:
- Include a signed **revocation list** artifact per tenant/environment:
  - `revocations.json` (content-addressed, signed by trust root or intermediate)
  - Contains revoked `key_id`s, reasons, and effective timestamps.
- Distribute revocation lists alongside Runtime Packs and/or through Orgo/Konnaxion sync channels.

Clients MUST:
- Consult the latest available revocation list before accepting a signature, when a revocation list is present.
- Fail closed if policy requires revocation checking and no revocation list is available.

## Verification responsibilities by component

### Orgo (control plane)
- MUST record: build_id, artifact ids, signer key_id, signature metadata.
- SHOULD enforce “no publish without signature” in environments where signatures are required.
- SHOULD manage rotation schedules and revocation list publication.

### Konnaxion (distribution + client UX)
- MUST verify signatures when present before activating a pack.
- MUST pin trust roots per tenant/environment.
- MUST enforce rollback/downgrade policy (see separate doc).

### Architect (renderer)
- SHOULD verify inputs are validated and (where required) signed before rendering.
- MUST include traceability, but does not need to re-sign artifacts unless it produces distributable outputs.

### SenTient (resolver)
- Not typically a signer.
- SHOULD sign resolver outputs only if the deployment treats resolver output as a distributable artifact (rare).

## Minimum security acceptance criteria
A deployment meets minimum Kristal v3 security criteria if:
1. Signed artifacts are verified fail-closed when signatures are present.
2. Trust roots are pinned and enforceable offline.
3. Key rotation is supported (overlap windows + key ids recorded).
4. Compromise response exists (revocation list distribution + re-issue).
5. Downgrade protection is implemented for pack activation (see rollback policy doc).

## Open questions (to finalize)
- Supported signature algorithms set (Ed25519 recommended baseline vs RSA compatibility needs)
- Whether Runtime Packs sign:
  - only the manifest, or
  - manifest + referenced file hashes (stronger)
- Required revocation policy level for “offline-only” constrained environments
- Whether to support transparency logs (append-only) as a future optional profile

===== END 07-security/key-management-and-trust-roots.md (#0027) =====

===== BEGIN 07-security/multi-tenancy-boundaries.md (#0028) =====
# Multi-tenancy boundaries (global content IDs + tenant access control layering)

## Status
Draft (Kristal v3)

## Purpose
Define the **multi-tenancy boundary model** for Kristal v3 so that:
- **IDs remain globally content-addressed** (same content → same `kristal_id`)
- **tenant isolation** is enforced by **access control + signing keys + distribution channels**
- operational systems (Orgo/Konnaxion) can safely manage builds, governance, and offline distribution without cross-tenant leakage

This document is normative where it uses MUST/SHOULD.

## Definitions
- **Tenant**: an isolated administrative/security domain (org, deployment, customer, jurisdiction).
- **Exchange**: canonical Kristal artifact; content-addressed source of truth.
- **Runtime Pack**: derived offline-executable artifact; distributed to clients/nodes.
- **Global content ID**: ID derived only from canonicalized content (not from tenant metadata).
- **Access layer**: authorization + distribution controls that determine who can obtain or use an artifact.
- **Signing domain**: key material and trust roots used to sign artifacts in a tenant/environment.

## Core model (v3)

### 1) Global content IDs (MUST)
- `kristal_id` MUST be computed solely from **canonicalized Exchange content** (JCS), excluding signatures and other non-content fields.
- The same Exchange content produced in two tenants MUST yield the same `kristal_id`.

Rationale: enables caching, deduplication, reproducible builds, and cross-implementation comparability.

### 2) Tenant isolation is layered above IDs (MUST)
Tenant separation MUST be enforced by:
- **access control** (who can fetch/see/use),
- **signing keys + trust roots** (who can trust/verify),
- **distribution channels** (where/how packs are delivered),
not by changing the content hash or `kristal_id`.

### 3) Tenant metadata MUST NOT influence core hashes (MUST)
Tenant identifiers, ACLs, approvals, workflow state, and distribution status MUST NOT be included in:
- Exchange content canonicalization for `kristal_id`,
- Exchange `content_hash`,
- Runtime Pack content hash (unless a separate declared integrity profile explicitly includes them—which is discouraged).

Tenant metadata belongs in Orgo/Konnaxion control-plane records, not in Kristal payload identity.

## Artifact visibility and authorization

### 4) Access decisions (MUST)
Implementations MUST enforce access control at these boundaries:
- **Exchange fetch / read**
- **Runtime Pack fetch / read**
- **Runtime Pack activation / use on client/node** (especially for offline caches)

Access checks MUST be tenant-scoped and MUST prevent:
- cross-tenant enumeration of artifact existence,
- inference via error messages (use consistent “not found or not authorized” responses where appropriate).

### 5) Content-addressability and privacy (SHOULD)
Because global IDs can enable cross-domain correlation (two tenants independently producing identical content share the same `kristal_id`), deployments SHOULD consider:
- restricting exposure of raw `kristal_id` values outside authorized contexts,
- using opaque handles in UI/API responses where correlation risk matters,
- ensuring error handling does not reveal whether a given `kristal_id` exists in another tenant.

If a deployment explicitly requires “no cross-tenant correlation,” it MUST use an additional tenant-scoped indirection layer (see Section 9) while keeping `kristal_id` global internally.

## Signing, trust roots, and tenant domains

### 6) Tenant-scoped signing domains (MUST)
- Each tenant/environment MUST have a defined **trust root set** (public keys / cert roots) used to verify signatures.
- Artifacts MAY be signed by tenant-specific keys even if IDs are global.
- Verification MUST use the tenant’s pinned trust roots.

### 7) Same content, different signatures (MUST)
It MUST be possible for:
- Tenant A and Tenant B to publish the same Exchange (same `kristal_id`)
- but sign it with different keys.

Signatures MUST be treated as **metadata** over the declared `content_hash` and MUST NOT change the `kristal_id`.

### 8) Distribution channel isolation (MUST)
Runtime Pack distribution MUST be isolated per tenant via:
- separate package indexes / feeds, or
- tenant-authenticated endpoints, or
- tenant-specific offline bundle channels.

Clients MUST NOT accept packs from untrusted channels even if signatures verify under some other tenant’s trust roots.

## Control-plane vs data-plane division (Orgo / Konnaxion)

### 9) Orgo is the control plane (MUST)
Orgo SHOULD store (tenant-scoped):
- workflow state (cases/tasks/approvals),
- who requested or approved builds,
- distribution status,
- audit logs,
- policy configuration per tenant,
- key references (KIDs) and trust-root sets.

Kristal artifacts SHOULD store only:
- content, manifests, reproducibility policy selections, and signatures.

### 10) Konnaxion distribution and offline caching (MUST)
Konnaxion clients/nodes MUST:
- verify signatures against tenant trust roots before using a pack,
- maintain tenant-separated caches (no cross-tenant cache reuse unless explicitly configured),
- enforce rollback/downgrade prevention within a tenant channel.

## Reproducibility and comparability across tenants

### 11) Reproducibility remains tenant-independent (MUST)
Given identical inputs and policy selections, two tenants compiling the same Exchange content MUST be able to produce:
- identical Exchange content hashes and `kristal_id`,
- byte-identical exports (if same export profile and serialization rules),
- reproducible Runtime Packs when the same portable policies are used.

### 12) Policy selection is tenant-configurable but recorded (MUST)
Tenants MAY choose different portable policies (ordering, row groups, filter parameters) for Runtime Packs.
When they do, those policy selections MUST be recorded in the manifests so packs remain comparable and reproducible within their policy class.

## Threat considerations (non-exhaustive)

### Correlation risk (SHOULD mitigate)
Global IDs can reveal that two tenants have identical content if IDs are exposed publicly.
Mitigations:
- opaque handles externally,
- tenant-authenticated lookup,
- do not expose IDs in URLs.

### Downgrade/rollback attacks (MUST mitigate)
- Clients MUST apply a per-tenant rollback/downgrade prevention policy (see `07-security/downgrade-rollback-policy.md`).
- Signed “latest” pointers or pinned release channels SHOULD be used.

### Cross-tenant cache pollution (MUST prevent)
- Client caches MUST be partitioned by tenant.
- Package indices MUST be tenant-authenticated.

## Recommended implementation patterns (non-normative)
- Use a **tenant-scoped artifact registry** that maps:
  - `tenant_artifact_handle` → (`kristal_id`, allowed channels, trust roots, policy class)
- Keep `kristal_id` as an internal canonical key, but avoid exposing it directly in unauthenticated contexts.
- Use structured logs with `{tenant_id, build_id, kristal_id}` but ensure log access is tenant-scoped.

## Open questions (to finalize)
- Do we require opaque handles everywhere externally, or only for public/unauthenticated contexts?
- Do we standardize a tenant registry schema as non-normative guidance (recommended) or a formal profile (likely non-normative)?
- How do we handle “shared public Kristals” intended to be cross-tenant by design (e.g., public education packs)? (Likely: separate public tenant/channel with its own trust roots.)

===== END 07-security/multi-tenancy-boundaries.md (#0028) =====

===== BEGIN 08-ops/failure-paths-and-resilience.md (#0029) =====
# Failure paths and resilience (non-normative)

## Status
Non-normative operational guidance (Kristal v3)

## Purpose

This document provides operational guidance for building and distributing Kristals reliably in the ecosystem:
- Orgo (workflow/orchestration)
- SenTient (resolution service)
- Kristal compiler (validation, Exchange finalize, Runtime Pack compile)
- Konnaxion (distribution/offline caching)
- Architect (deterministic rendering)

These patterns are **not** part of Kristal artifact schemas and do not affect conformance, except where core/spec requirements already mandate behaviors (e.g., fail-closed verification, “no compile on fail”).

## Principles

- **Fail fast, fail closed where integrity is involved.**
- **Preserve ambiguity rather than blocking pipelines** (SenTient resolution).
- **Quarantine poison inputs** (DLQ) instead of infinite retry or silent drop.
- **Bound resource usage** (timeouts/quotas) to protect offline and multi-tenant systems.
- **Prefer immutable snapshots** (Exchange + Runtime Pack releases), and treat new data as a new build.

## 1) Circuit breaker (SenTient resolution calls)

### Concept
A circuit breaker prevents repeated calls to an unhealthy dependency, reducing cascading failures.

### Problem it addresses
Resolution services can fail or degrade (timeouts, high latency, partial outages). Without protection, the build pipeline stalls, retries amplify load, and Orgo queues back up.

### Recommended approach
- Wrap all SenTient calls behind a circuit breaker per tenant and per resolver endpoint.
- Use a **funnel-friendly fallback**: if SenTient is unavailable, preserve unresolved ambiguity and continue if policy allows, or stop early with a clear failure reason.

### Suggested states
- **Closed:** normal operation
- **Open:** calls fail fast (no network call)
- **Half-open:** limited probe calls to test recovery

### Trigger thresholds (guidance)
- Open after N consecutive timeouts/errors within a short window.
- Remain open for a cool-down interval, then half-open probes.

### Output semantics
- If SenTient fails and the pipeline policy allows “unresolved preserved,” emit resolved-claim output with:
  - `status = "unresolved"`
  - `candidates = []` or last-known candidates
  - `warnings[]` with reason and correlation IDs

### Pitfalls
- Hiding failures: always log and surface circuit state changes.
- Global breakers: avoid one tenant taking down all tenants (use per-tenant scoping).

## 2) Dead letter queue (DLQ) for ingestion and build stages

### Concept
A DLQ stores messages/inputs that cannot be processed after bounded retries.

### Problem it addresses
“Poison inputs” (corrupt PDFs, malformed Claim-IR, pathological resolution cases) can block queues indefinitely if retried endlessly, or disappear if dropped.

### Recommended approach
- Use staged queues for: ingest → extract → resolve → validate → publish → distribute.
- Each stage has:
  - bounded retries
  - exponential backoff with jitter
  - DLQ on repeated failure

### DLQ payload requirements (guidance)
Include:
- `build_id`
- `tenant_id`
- `stage`
- `input_ref` (pointer to source or blob hash)
- `error_code` and a bounded error message
- `attempt_count`
- timestamps

### Operational loop
- DLQ items create Orgo Cases/Tasks automatically for triage.
- Triage outcomes:
  - fix input (requeue)
  - adjust policy (e.g., relax a non-core constraint)
  - mark as rejected with recorded reason

### Pitfalls
- DLQ as a graveyard: require ownership, SLAs, and dashboards.
- Infinite DLQ growth: apply retention + sampling for high-volume failures.

## 3) Timeouts and cancellation

### Concept
Every stage must have bounded execution time to prevent resource exhaustion and queue collapse.

### Recommended guidance (by stage)
- **Extraction (LLM/classical):** hard timeout; emit partial Claim-IR only if schema-valid and explicitly marked partial.
- **Resolution (SenTient):** hard timeout; preserve unresolved state; record warning.
- **Validation:** hard timeout; on timeout, treat as failure (no compile).
- **Pack compilation:** hard timeout; safe abort; no partial pack publication.
- **Distribution:** retry with backoff; never serve incomplete packs as “current.”

### Cancellation propagation
- If Orgo cancels a build, downstream workers MUST stop and emit a final build status record.
- Cancellation must not produce partially signed/published artifacts.

### Pitfalls
- Long tail: one slow job blocks worker pools.
- Partial publication: ensure atomic publish/commit semantics.

## 4) Quotas and rate limiting (multi-tenancy safety)

### Concept
Quotas bound per-tenant resource usage to protect system stability.

### Recommended quota dimensions
- Ingest volume (bytes/day, docs/day)
- Resolution calls (requests/min, tokens/day if applicable)
- Validation complexity (statements per build, references per statement)
- Build concurrency (active builds per tenant)
- Distribution bandwidth (MB/day per region)

### Enforcement guidance
- Enforce at Orgo orchestration boundary (admission control).
- Return structured errors with remediation hints.
- Provide “burst then throttle” behavior rather than hard drops when possible.

### Pitfalls
- Non-deterministic throttling affecting outputs: throttling MUST not change artifacts. It only changes scheduling.

## 5) Backpressure and queue hygiene

### Concept
When downstream is slow, upstream must slow down safely.

### Recommended approach
- Bounded queues with explicit backpressure signals to producers.
- Priority queues for:
  - critical rebuilds (security/rollback)
  - small builds (fast wins)
  - user-facing hotfixes

### Pitfalls
- Priority inversion: ensure large jobs cannot starve all others indefinitely.

## 6) Integrity-critical fail-closed points (must align with spec)

These are operational restatements of spec-level requirements:

- **Hash/signature verification is fail-closed** when declared.
- **No compile on validation failure**.
- **Atomic publish**: a release is either fully published and verifiable, or not published at all.
- **Immutable snapshots**: updates produce a new Exchange/Pack ID.

## 7) Release safety: canary / blue-green (distribution)

### Concept
Reduce blast radius when shipping new packs.

### Recommended approach
- Canary: deliver new pack to a small cohort/region first.
- Blue-green: keep previous pack live; switch traffic when canary passes.
- Always support rollback to last-known-good pack (subject to downgrade prevention policy).

### Health signals
- verification success rate
- query error rate
- pack download success and latency
- device cache hit rates (Konnaxion)

### Pitfalls
- Rollback that breaks integrity rules: ensure rollback is a signed, pinned prior release, not an unsigned artifact.

## 8) Observability: correlation IDs and structured logs

Required operational identifiers (guidance):
- `build_id` (end-to-end)
- `kristal_id` / `exchange_id`
- `runtime_pack_id`
- `claim_id` (Claim-IR / Exchange)
- `input_ref` (blob hash or source URI hash)
- `tenant_id`

Log events at:
- stage start/end
- circuit breaker state transitions
- retries and DLQ moves
- validation failure summaries (bounded)

## 9) Suggested minimal error taxonomy (guidance)

- `INGEST_PARSE_ERROR`
- `EXTRACT_SCHEMA_INVALID`
- `RESOLVE_TIMEOUT`
- `RESOLVE_DEP_UNAVAILABLE`
- `VALIDATION_FAILED`
- `VALIDATION_TIMEOUT`
- `COMPILE_FAILED`
- `PUBLISH_ATOMICITY_FAILED`
- `VERIFY_SIGNATURE_FAILED`
- `DISTRIBUTION_FAILED`
- `QUOTA_EXCEEDED`

## Appendix: recommended “least-worst” defaults

- Circuit breaker enabled for SenTient by default.
- DLQs enabled for every pipeline stage.
- Hard timeouts for every stage; validation timeout treated as failure.
- Quotas enforced at Orgo admission control.
- Canary rollout for packs before global promotion.


===== END 08-ops/failure-paths-and-resilience.md (#0029) =====

===== BEGIN 08-ops/logging-and-correlation-ids.md (#0030) =====
````md
# Logging and correlation IDs (non-normative)

## Status
Non-normative operational guidance (Kristal v3)

## Purpose

This document defines a consistent logging and correlation-ID practice for the Kristal build and distribution ecosystem (Orgo × SenTient × Architect × Konnaxion). The goal is to:
- make failures diagnosable quickly
- support reliable audit and provenance workflows
- enable end-to-end tracing across pipeline stages
- preserve multi-tenant isolation while retaining debuggability

These practices are **not** embedded as first-class objects in Kristal Exchange/Runtime schemas. They are operational conventions used by build/distribution systems and referenced in logs, metrics, and Orgo audit records.

## Principles

- Use **structured logs** (JSON) with stable field names.
- Generate correlation IDs at the **earliest** boundary (Orgo admission).
- Propagate IDs across service boundaries (HTTP headers, message metadata, job context).
- Avoid PII in logs; log hashes/pointers instead.
- Prefer immutable identifiers (content-addressed IDs) for durable linkage.

## Core identifiers

### 1) `build_id` (required)
**Scope:** One end-to-end Kristal build workflow execution.  
**Generated by:** Orgo (workflow/orchestrator).  
**Format:** UUIDv4 (recommended) or equivalent unique opaque string.  
**Stability:** Constant across all stages and retries.

Used for:
- tracing ingestion → extraction → resolution → validation → publish → distribution
- grouping all logs/metrics for a single build run

### 2) `tenant_id` (required in multi-tenant deployments)
**Scope:** Tenant or namespace boundary for admission control and isolation.  
**Generated by:** Orgo / identity layer.  
**Format:** stable opaque ID.

### 3) Content-addressed IDs (required where applicable)

#### `exchange_id`
Content-addressed identifier for the finalized Kristal Exchange artifact.

#### `runtime_pack_id`
Content-addressed identifier for the Runtime Pack artifact derived from Exchange.

#### `kristal_id` (if used as the canonical “unit id” in your system)
If you use `kristal_id` as a top-level unit ID distinct from `exchange_id`, it should be logged consistently as well.

### 4) Claim-level IDs

#### `claim_id` (required when operating at claim granularity)
Stable identifier for a Claim-IR/Exchange claim.  
Used to trace:
- extractor outputs → resolution outcomes → validation results → Exchange statements → Architect render outputs

#### `statement_id` (optional, if you differentiate statements from claims)
If a claim expands into multiple normalized statements, log `statement_id` to disambiguate.

### 5) Input references

#### `input_ref` (recommended)
A hash/pointer for the original input unit (document, email archive, PDF blob, dataset chunk).  
Prefer:
- content hash (sha256) of the raw blob
- or stable URI hash if raw cannot be logged

Avoid logging raw URLs or file paths if they can leak PII.

### 6) Resolution references

#### `surface_id` / `mention_id` (optional)
If SenTient processes many surfaces/mentions, log a stable ID per mention to isolate failures.

#### `candidate_id` (optional)
If SenTient returns ranked candidate QIDs/PIDs, log the chosen candidate ID when selection is made (and log ambiguity when selection is not made).

## Propagation rules

### Orgo → workers/services
- Orgo MUST attach `build_id` and `tenant_id` to:
  - queue messages
  - job metadata
  - API requests to SenTient/Architect/compiler

### Service-to-service (HTTP) propagation (recommended)
Use headers:
- `X-Build-Id: <build_id>`
- `X-Tenant-Id: <tenant_id>`
- `X-Trace-Id: <trace_id>` (if using distributed tracing)
- `X-Parent-Span-Id: <span_id>` (if applicable)

### Message queue propagation (recommended)
Attach IDs as message metadata fields:
- `build_id`, `tenant_id`, `stage`, `attempt`

## Structured log fields (recommended minimum set)

All services SHOULD emit logs with the following fields where applicable:

Final recommended minimum fields:
- `ts` (RFC 3339 timestamp)
- `level` (`DEBUG|INFO|WARN|ERROR`)
- `service` (`orgo|sentient|kristal-compiler|architect|konnaxion|...`)
- `stage` (`ingest|extract|resolve|validate|exchange_finalize|pack_compile|distribute|render`)
- `event` (short stable string, e.g., `STAGE_START`, `VALIDATION_FAILED`)
- `build_id`
- `tenant_id` (if multi-tenant)
- `exchange_id` (once known)
- `runtime_pack_id` (once known)
- `claim_id` (when applicable)
- `input_ref` (when applicable)
- `attempt` (retry number)
- `duration_ms` (for completion events)
- `error_code` and `error_message` (bounded) for failures

## Event taxonomy (recommended)

### Stage lifecycle
- `STAGE_START`
- `STAGE_END`
- `STAGE_RETRY`
- `STAGE_CANCELLED`

### Resolution (SenTient)
- `RESOLVE_REQUEST`
- `RESOLVE_TIMEOUT`
- `RESOLVE_CIRCUIT_OPEN`
- `RESOLVE_UNRESOLVED_PRESERVED`

### Validation
- `VALIDATION_START`
- `VALIDATION_FAILED`
- `VALIDATION_TIMEOUT`

### Exchange / Pack
- `EXCHANGE_FINALIZE_START`
- `EXCHANGE_FINALIZE_SUCCESS`
- `PACK_COMPILE_START`
- `PACK_COMPILE_SUCCESS`

### Integrity and verification
- `SIGNATURE_VERIFY_FAILED`
- `HASH_MISMATCH`
- `FAIL_CLOSED_TRIGGERED`

### Distribution (Konnaxion)
- `PACK_PUBLISH_START`
- `PACK_PUBLISH_SUCCESS`
- `PACK_ROLLOUT_CANARY_START`
- `PACK_ROLLOUT_CANARY_FAIL`
- `PACK_ROLLBACK`

### DLQ / quarantine
- `DLQ_ENQUEUE`
- `DLQ_TRIAGE_DECISION`

## Recommended linkage in artifacts (non-normative)

Do not embed operational meta-structures into Exchange/Pack schemas as first-class objects. However:
- `build.build_id` is already captured in the Runtime Pack Manifest (core requirement).
- Exchange manifests may record a `build_id` for traceability, if desired.
- Validation reports should include `build_id` and `claim_id` fields so validation failures can be traced precisely.

## Privacy and security guidance

- Do not log raw extracted text unless explicitly required and protected.
- Prefer hashed references to evidence blobs and documents.
- Avoid logging full signatures or private key material.
- For public logs, redact or hash `tenant_id` if it could be sensitive.

## Examples (non-normative)

### Stage start log
```json
{
  "ts": "2026-01-07T14:10:12Z",
  "level": "INFO",
  "service": "kristal-compiler",
  "stage": "validate",
  "event": "STAGE_START",
  "build_id": "f3a2c6f8-7dd4-4a5f-9b84-4a0a7b1d0d0d",
  "tenant_id": "tenant_123",
  "input_ref": "sha256:9b3c...e21a",
  "attempt": 1
}
````

### Validation failure log

```json
{
  "ts": "2026-01-07T14:10:44Z",
  "level": "ERROR",
  "service": "kristal-compiler",
  "stage": "validate",
  "event": "VALIDATION_FAILED",
  "build_id": "f3a2c6f8-7dd4-4a5f-9b84-4a0a7b1d0d0d",
  "tenant_id": "tenant_123",
  "claim_id": "claim_7f2b...",
  "error_code": "VALIDATION_FAILED",
  "error_message": "P31 value type mismatch",
  "duration_ms": 32150
}
```

## Appendix: recommended dashboards (guidance)

* Build success rate by stage and tenant
* Median/p95 stage duration
* SenTient timeout rate + circuit breaker opens
* Validation failure reasons top-N
* Pack publish success + rollback events
* DLQ depth and age

```
```

===== END 08-ops/logging-and-correlation-ids.md (#0030) =====

===== BEGIN 08-ops/operational-guidance-template.md (#0031) =====
````md
# Operational guidance template (concept → problem → solution → when → pitfalls)

## Status
Template (non-normative)

## Purpose
A consistent structure for operational and implementation guidance across the Kristal ecosystem (Orgo, SenTient, Architect, Konnaxion).  
This template is **non-normative**: it does not define conformance requirements for Kristal artifacts.  
Use it to document failure paths, resilience, observability, and “least-worst” trade-offs.

---

## 1) Concept
**Name:**  
**One-liner:** (What it is)

**Applies to:** (Orgo / SenTient / Architect / Konnaxion / Compiler / Client)  
**Lifecycle stage:** (ingest / extract / resolve / validate / compile / export / distribute / query / render)

**Primary goal:** (e.g., availability, correctness, reproducibility, isolation)  
**Secondary goals:** (e.g., latency, cost, debuggability)

---

## 2) Problem
**What can go wrong?**  
- Failure modes: (timeouts, partial outputs, poisoned inputs, overload, nondeterminism, cache corruption, etc.)
- Blast radius: (single build, tenant, region, global distribution)
- User-facing impact: (missing packs, stale knowledge, incorrect output, blocked pipeline)

**How it fails today (if known):**  
- Symptoms:
- Triggers:
- Observed frequency:

---

## 3) Solution
**Approach:** (What you do and why)

**Mechanics (concrete):**
- Inputs:
- Outputs:
- State transitions:
- Retry policy:
- Backoff policy:
- Quarantine / DLQ policy:
- Timeouts and resource limits:
- Determinism guarantees: (what must remain identical across reruns)

**Data contracts / artifacts involved:**
- Exchange / Runtime Pack / Claim-IR / Resolved Claim-IR / Validation Report
- Which IDs must be carried end-to-end: (build_id, kristal_id, claim_id, evidence_id, tenant_id)

**Security considerations:**
- Trust roots / signature verification points
- Tenant isolation boundaries
- Downgrade/rollback rules

---

## 4) When to use
**Use when:**
- (e.g., dependency is flaky; workload spikes; offline distribution is required; RDF canonicalization is expensive)

**Do not use when:**
- (e.g., it would mask correctness failures; it would introduce nondeterministic outputs; it enlarges the standard surface area)

**Preconditions / dependencies:**
- (e.g., feature flags, queue support, local disk cache, stable clock, monotonic counters)

---

## 5) Pitfalls and trade-offs
**Pitfalls:**
- (e.g., silent degradation; retry storms; inconsistent caches; partial acceptance of probabilistic results)

**Trade-offs:**
- Correctness vs availability:
- Latency vs cost:
- Reproducibility vs performance:
- Isolation vs deduplication:

**Anti-patterns to avoid:**
- “Fail-open” when integrity is declared
- Writing unresolved ambiguity as resolved facts
- Letting operational metadata affect content hashes/IDs
- Making downstream generation introduce new facts

---

## 6) Observability
**Logs (structured fields required):**
- tenant_id
- build_id
- kristal_id
- stage
- attempt
- duration_ms
- outcome (success/fail/partial)
- error_code (stable)
- dependency (if external call)

**Metrics:**
- throughput (items/sec)
- success/failure rates
- retry rates
- queue depth / lag
- cache hit rate
- signature verification failures
- validation error counts by code

**Tracing:**
- Correlation IDs propagated across services
- Spans for: resolve, validate, compile, export, distribute, query, render

**Dashboards / alerts:**
- SLOs:
- paging thresholds:
- anomaly detection:

---

## 7) Runbook
**Detection:**
- What alerts fire?
- What dashboards to check first?

**Mitigation:**
- Step-by-step actions (ordered)
- Safe fallback modes (must remain deterministic)
- How to quarantine inputs / disable profile / roll back pack

**Recovery:**
- Criteria for returning to normal mode
- Post-incident checks (repro tests, signature checks, cache consistency)

**Postmortem notes (fields):**
- Root cause:
- Prevent recurrence:
- Action items:

---

## 8) Example (optional)
**Scenario:**  
**Before:**  
**After:**  
**Key outputs (sample log lines / fields):**
```json
{
  "tenant_id": "…",
  "build_id": "…",
  "kristal_id": "…",
  "stage": "resolve",
  "duration_ms": 1234,
  "outcome": "fail",
  "error_code": "SENTIENT_TIMEOUT"
}
````

---

## 9) Versioning and ownership

**Owner team:**
**Last updated:**
**Applies to versions:** (Kristal v3.x, Orgo version, etc.)
**Change log:**

* YYYY-MM-DD: …

```
```

===== END 08-ops/operational-guidance-template.md (#0031) =====

===== BEGIN 08-ops/release-strategies.md (#0032) =====
# Release Strategies for Kristal Runtime Packs (Blue/Green, Canary)

## Status
Draft (non-normative operational guidance)

## Purpose
Define operational release strategies for distributing **Kristal Runtime Packs** safely (especially to offline or constrained environments) while preserving Kristal v3’s requirements:
- deterministic artifacts,
- fail-closed integrity,
- auditable release records,
- downgrade/rollback safety.

This document is **non-normative**: it does not change Kristal artifact formats or conformance. It provides recommended operational patterns for Orgo (control plane) and Konnaxion (distribution layer).

---

# 1. Terms and goals

## Terms
- **Pack**: a Kristal Runtime Pack artifact (manifest + payloads).
- **Release**: a versioned publication event (Orgo release record referencing pack_id, signatures, channels).
- **Channel**: a distribution target grouping (tenant, region, device cohort, environment).
- **Cohort**: a subset of a channel (e.g., 1% of devices).

## Goals
- Minimize blast radius of a bad pack release (bad data, bad build, bad performance).
- Preserve offline correctness: never run a pack whose integrity fails verification.
- Support fast rollback without creating “downgrade vulnerabilities.”
- Maintain auditable linkage: build → release → distribution → device state.

---

# 2. Release invariants (recommended)

These invariants should hold regardless of rollout strategy:

1. **Immutable pack identity**
   - A `pack_id` identifies immutable content.
   - Never “fix” a pack in place; publish a new pack.

2. **Fail-closed verification**
   - If signatures/hashes are declared, every distribution node and client should verify before activation.

3. **Auditable release records**
   - Every activation should be traceable to a Release record with pack_id, signing key, timestamp, and channel.

4. **Explicit rollback policy**
   - Rollback is allowed only to known-good versions within a defined safe window, respecting minimum-version pins.

---

# 3. Blue/Green releases (recommended default)

## 3.1 Concept
Maintain two production slots per channel:
- **Blue**: current active pack version
- **Green**: new candidate pack version

Devices or nodes only switch to Green once Green has been validated in production-like conditions.

## 3.2 Procedure
1. **Publish Green**
   - Orgo creates a Release referencing the new pack_id.
   - Distribution replicates pack payloads to the Green slot.

2. **Verify at rest**
   - Edge nodes/devices verify:
     - manifest hash,
     - payload hashes,
     - signatures (if present).
   - Verification failure blocks activation.

3. **Warm-up / readiness checks**
   - Run pack-local checks:
     - query smoke tests (basic triple patterns),
     - join-cap behavior,
     - performance sanity (latency thresholds),
     - memory footprint thresholds.
   - Log outcomes with correlation IDs.

4. **Switch traffic**
   - Flip the channel pointer from Blue → Green.
   - Keep Blue retained for a defined rollback window.

5. **Post-switch monitoring**
   - Observe error codes, query latencies, resource usage.
   - If thresholds exceed, trigger rollback.

## 3.3 Advantages
- Simple mental model.
- Predictable rollback.
- Works well for offline package distribution where clients may activate asynchronously.

## 3.4 Pitfalls
- Storage overhead (two slots).
- Must define the activation pointer clearly to avoid split-brain (some devices on Blue, some on Green is expected; the important part is auditability).

---

# 4. Canary releases (recommended for high-risk changes)

## 4.1 Concept
Roll out the new pack to a small cohort first, validate, then expand.

## 4.2 Procedure
1. **Create cohorts**
   - Example: 1% → 10% → 50% → 100%
   - Cohorts should be stable and deterministic (hash(device_id) mod 100).

2. **Canary publish**
   - Orgo creates a Release for cohort 1%.
   - Distribution makes the pack available to the cohort only.

3. **Activation gating**
   - Devices verify integrity and run smoke tests before activation.

4. **Promote**
   - If health metrics are good for a defined observation window, expand to next cohort.

5. **Abort and rollback**
   - If health metrics fail, stop promotion and revert cohorts to the previous pack pointer.

## 4.3 Metrics to watch
- Integrity verification failures
- Query error rates (especially strict join-cap errors)
- Median/P95 query latency for representative workloads
- Memory pressure / OOM events on constrained devices
- Pack download failures or excessive download size complaints

## 4.4 Pitfalls
- Requires cohort assignment stability and a clean mechanism for cohort targeting.
- Offline devices may “skip” cohorts; treat cohort checks as “best effort” and rely on integrity + smoke tests at activation time.

---

# 5. Rollback and downgrade safety (critical)

Rollback is operationally necessary, but uncontrolled downgrade is a security risk.

## 5.1 Recommended rules
- **Rollback pointer**: channel pointer can move back to a prior pack_id only if that pack_id is:
  - still within the retention window,
  - still signed by a trusted key,
  - not below the channel’s **minimum pinned version**.

- **Minimum version pin**
  - Maintain a per-channel `min_allowed_release_version`.
  - Clients MUST NOT activate packs below this minimum (even if cached).

- **Revocation**
  - If a pack is discovered invalid/vulnerable, revoke it:
    - mark as revoked in release metadata,
    - distribute revocation list to clients,
    - bump minimum pin to exclude it.

(See also `07-security/downgrade-rollback-policy.md`.)

---

# 6. Offline and constrained environments (practical notes)

## 6.1 Activation is local and asynchronous
Offline devices may:
- download a pack later than publication,
- activate it later than download.

Therefore:
- integrity verification MUST be done at activation time.
- store the activation decision with an audit marker (pack_id + release_id + timestamp).

## 6.2 Storage constraints
If devices cannot hold Blue+Green simultaneously:
- hold the previous pack’s manifest + signatures at minimum, or
- implement a “checkpoint pack” strategy: keep last known-good pack payloads for rollback where feasible.

## 6.3 Delta updates (optional)
If packs are large:
- use delta distribution at the transport layer,
- but ensure the resulting final payload hashes match the declared pack manifest hashes.

---

# 7. Suggested control-plane data model (informative)

A practical Orgo/Konnaxion release system typically maintains:

- `BuildRecord(build_id, pack_id, kristal_id, hashes, signatures, policies, inputs, compiler_version, config_hash)`
- `Release(release_id, channel_id, pack_id, signing_key_id, published_at, status)`
- `ChannelPointer(channel_id, active_release_id, min_allowed_release_version)`
- `DeviceState(device_id, channel_id, active_pack_id, last_verified_at, verification_status)`

This is illustrative; exact implementation is system-specific.

---

# 8. Recommended “default strategy”

For most deployments:
- Use **Blue/Green** as the default.
- Add **Canary** for high-risk changes:
  - new policies (ordering, row-groups, filters),
  - large schema shifts,
  - new query extensions,
  - new client versions.

---

# 9. Checklist

## Blue/Green
- [ ] Pack published + verified at rest
- [ ] Smoke tests pass
- [ ] Switch pointer
- [ ] Monitor and rollback window defined
- [ ] Minimum version pin updated when needed

## Canary
- [ ] Cohorts stable and targetable
- [ ] Observation metrics defined
- [ ] Promotion steps defined
- [ ] Abort/rollback is one operation
- [ ] Offline activation still verifies integrity + runs smoke tests

===== END 08-ops/release-strategies.md (#0032) =====

===== BEGIN 09-test-vectors/jcs/expected-hashes.txt (#0033) =====
# Kristal v3 JCS test vectors — expected hashes
# Hash algorithm: SHA-256
# Hash input: UTF-8 bytes of expected_canonical_json (RFC 8785 JCS output)
# Format: <vector_id> <sha256_hex>

jcs-001 43258cff783fe7036d8a43033f830adfc60ec037382473548ac742b888292777
jcs-002 59d176cd99b72175a563664f429ecec5d1cb31754d7d090b0592bda9b53fc021
jcs-003 1956211cdd1b997e12419186832911195c511ff444db406c7e53fd35b600e21d
jcs-004 17073ac6186d8c60c0c0da712ce30cdb52ed5a9155f616983da39a9785dce715
jcs-005 31966e8f9b0d5b511eab8f56edc1edb07c7403f8bd904a165c0025b0503ec0e3
jcs-006 49b33db53718cfff9f0ca7cef74a955f68e0bdb941774e5fd92b75c3fd658a6c
jcs-007 8811ce97e7b0a5549448d9c8243ec05ba8fb57a40354b82b1d0c5c513cc63856
jcs-008 53152b34512bdb2f05bbfa2d41f4f7e5e379e5df67c831f3039ccacc7b1ea7bd

===== END 09-test-vectors/jcs/expected-hashes.txt (#0033) =====

===== BEGIN 09-test-vectors/jcs/README.md (#0034) =====
````md
# JCS Test Vectors (Kristal v3)

## Status
Draft (normative test-vector guidance)

## Purpose
This folder contains **golden test vectors** for Kristal v3’s canonicalization and identity rules.

Kristal v3 requires that:
- `canonical_json` is **RFC 8785 JSON Canonicalization Scheme (JCS)**, and
- content-addressed IDs (e.g., `kristal_id`) are computed as:

`sha256( JCS(json_object_without_signatures) )`

These vectors ensure that independent implementations in different languages compute identical canonical bytes and identical hashes.

---

# Files in this folder

- `vectors.json`  
  A collection of JCS input cases and expected canonical outputs.

- `expected-hashes.txt`  
  Expected SHA-256 hashes for each vector’s canonical output.

---

# Vector format (recommended)

Each entry in `vectors.json` SHOULD use the following shape:

```json
{
  "id": "jcs-0001",
  "description": "Brief description of the case",
  "input": { "...": "original JSON object" },
  "expected_canonical": "{\"a\":1,\"b\":2}",
  "expected_sha256_hex": "..."
}
````

Notes:

* `expected_canonical` MUST be the exact UTF-8 string output of JCS.
* `expected_sha256_hex` MUST be the SHA-256 digest of `expected_canonical` bytes (UTF-8), lower-case hex.

Implementations MAY split `expected_sha256_hex` into `expected-hashes.txt` instead of embedding it in JSON, but the correspondence MUST be unambiguous.

---

# Required coverage (minimum)

The vector set MUST include cases covering:

## 1) Object key ordering

* keys out of order in input
* nested objects

## 2) Arrays

* arrays preserve order
* nested arrays/objects

## 3) Numbers (critical)

* integers vs floating-point
* negative values
* edge cases around exponent notation
* values that must not be represented in a non-canonical form

## 4) Strings and escaping

* quotes, backslashes
* unicode escapes
* control characters

## 5) Booleans and null

* `true`, `false`, `null`

## 6) “Signature exclusion” fixture (Kristal-specific)

Include at least one fixture where:

* the input contains a signature envelope section (or mock signature fields),
* the canonicalization/hash input explicitly excludes those fields,
* the expected canonical output corresponds to “without signatures.”

This ensures implementations match Kristal’s “remove signatures → canonicalize → hash” rule.

---

# How to use these vectors

## Step 1: Canonicalization

For each vector:

1. Parse `input` into an in-memory JSON object.
2. Serialize it using **JCS**.
3. Compare the resulting bytes (UTF-8) to `expected_canonical`.

## Step 2: Hashing

1. Compute SHA-256 over the canonical bytes.
2. Compare to `expected_sha256_hex` (or the corresponding line in `expected-hashes.txt`).

Any mismatch indicates:

* the implementation is not RFC 8785 compliant, or
* the implementation is applying additional transformations, or
* signature fields were not excluded correctly.

---

# Conformance requirement

A Kristal v3 core implementation MUST:

* ship a vector set (this folder), and
* pass all vectors in CI.

If an implementation claims conformance but fails these vectors, its IDs are not interoperable.

---

# Updating the vectors

## Versioning

If vectors change materially:

* increment the vector set version (add `vector_set_version` to `vectors.json` root or to this README),
* preserve old vectors if possible to avoid breaking downstream CI.

## Adding new vectors

Prefer adding new IDs rather than modifying existing ones, unless correcting an error.

---

# Suggested commands (informative)

Examples of what a test runner should do:

* Load `vectors.json`
* For each vector, run:

  * `canonical = JCS(input)`
  * `hash = sha256(canonical)`
  * assert equality with expected values

The exact runner is language-specific.

```
```

===== END 09-test-vectors/jcs/README.md (#0034) =====

===== BEGIN 09-test-vectors/jcs/vectors.json (#0035) =====
{
  "profile_id": "kristal.v3:jcs-rfc8785",
  "profile_version": "1",
  "hash_alg": "sha256",
  "notes": "Each vector provides input_json as JSON text (may include whitespace). Parse input_json, apply RFC 8785 JCS canonicalization, then compute SHA-256 over UTF-8 bytes of expected_canonical_json.",
  "vectors": [
    {
      "id": "jcs-001",
      "description": "Object member ordering (simple)",
      "input_json": "{ \"b\": 2, \"a\": 1 }",
      "expected_canonical_json": "{\"a\":1,\"b\":2}",
      "expected_sha256_hex": "43258cff783fe7036d8a43033f830adfc60ec037382473548ac742b888292777",
      "expected_sha256": "sha256:43258cff783fe7036d8a43033f830adfc60ec037382473548ac742b888292777"
    },
    {
      "id": "jcs-002",
      "description": "Object member ordering (nested)",
      "input_json": "{\"z\": {\"b\": 2, \"a\": 1}, \"a\": 0}",
      "expected_canonical_json": "{\"a\":0,\"z\":{\"a\":1,\"b\":2}}",
      "expected_sha256_hex": "59d176cd99b72175a563664f429ecec5d1cb31754d7d090b0592bda9b53fc021",
      "expected_sha256": "sha256:59d176cd99b72175a563664f429ecec5d1cb31754d7d090b0592bda9b53fc021"
    },
    {
      "id": "jcs-003",
      "description": "Whitespace removal and array order preserved",
      "input_json": "{ \"a\" : [ 3 , 2 , 1 ] }",
      "expected_canonical_json": "{\"a\":[3,2,1]}",
      "expected_sha256_hex": "1956211cdd1b997e12419186832911195c511ff444db406c7e53fd35b600e21d",
      "expected_sha256": "sha256:1956211cdd1b997e12419186832911195c511ff444db406c7e53fd35b600e21d"
    },
    {
      "id": "jcs-004",
      "description": "Literals (null/true/false) and ordering",
      "input_json": "{\"b\": true, \"a\": null, \"c\": false}",
      "expected_canonical_json": "{\"a\":null,\"b\":true,\"c\":false}",
      "expected_sha256_hex": "17073ac6186d8c60c0c0da712ce30cdb52ed5a9155f616983da39a9785dce715",
      "expected_sha256": "sha256:17073ac6186d8c60c0c0da712ce30cdb52ed5a9155f616983da39a9785dce715"
    },
    {
      "id": "jcs-005",
      "description": "String escaping (quotes, backslash, control escapes)",
      "input_json": "{\"a\":\"\\\"\\\\\\b\\f\\n\\r\\t\"}",
      "expected_canonical_json": "{\"a\":\"\\\"\\\\\\b\\f\\n\\r\\t\"}",
      "expected_sha256_hex": "31966e8f9b0d5b511eab8f56edc1edb07c7403f8bd904a165c0025b0503ec0e3",
      "expected_sha256": "sha256:31966e8f9b0d5b511eab8f56edc1edb07c7403f8bd904a165c0025b0503ec0e3"
    },
    {
      "id": "jcs-006",
      "description": "Unicode characters are not escaped",
      "input_json": "{\"a\":\"é\",\"b\":\"漢字\"}",
      "expected_canonical_json": "{\"a\":\"é\",\"b\":\"漢字\"}",
      "expected_sha256_hex": "49b33db53718cfff9f0ca7cef74a955f68e0bdb941774e5fd92b75c3fd658a6c",
      "expected_sha256": "sha256:49b33db53718cfff9f0ca7cef74a955f68e0bdb941774e5fd92b75c3fd658a6c"
    },
    {
      "id": "jcs-007",
      "description": "Numbers already in canonical form",
      "input_json": "{\"d\":1.5,\"c\":-1,\"b\":1,\"a\":0}",
      "expected_canonical_json": "{\"a\":0,\"b\":1,\"c\":-1,\"d\":1.5}",
      "expected_sha256_hex": "8811ce97e7b0a5549448d9c8243ec05ba8fb57a40354b82b1d0c5c513cc63856",
      "expected_sha256": "sha256:8811ce97e7b0a5549448d9c8243ec05ba8fb57a40354b82b1d0c5c513cc63856"
    },
    {
      "id": "jcs-008",
      "description": "Ordering by Unicode code points (A before a)",
      "input_json": "{\"a\":1,\"A\":2,\"aa\":3}",
      "expected_canonical_json": "{\"A\":2,\"a\":1,\"aa\":3}",
      "expected_sha256_hex": "53152b34512bdb2f05bbfa2d41f4f7e5e379e5df67c831f3039ccacc7b1ea7bd",
      "expected_sha256": "sha256:53152b34512bdb2f05bbfa2d41f4f7e5e379e5df67c831f3039ccacc7b1ea7bd"
    }
  ]
}

===== END 09-test-vectors/jcs/vectors.json (#0035) =====

===== BEGIN 09-test-vectors/rdfc/README.md (#0036) =====
```markdown
# RDFC Test Vectors and Fixtures (Optional Profile)

## Status
Draft

## Purpose
This directory contains pointers and packaging conventions for the **optional** Kristal v3 profile:

- `profile-rdf-integrity-rdfc` (RDF dataset canonicalization + `rdf_hash` + CI gating)

The goal is to make RDF integrity **verifiable and interoperable** by:
- standardizing how fixtures are stored and referenced,
- standardizing how expected hashes are recorded,
- documenting which RDFC conformance tests are gated in CI,
- and ensuring resource limits are captured alongside fixtures.

## Scope
In scope:
- Fixture layout and naming
- Required metadata for reproducing `rdf_hash`
- Expected output recording
- CI gating configuration pointers

Out of scope:
- Shipping the full W3C RDFC test suite inside this repo (implementations may vendor it or reference it)

## Directory layout (recommended)
```

09-test-vectors/rdfc/
README.md
fixtures/
wdqs-full/
case-0001/
export.rdf.nq
export.manifest.json
expected.rdf_hash.sha256
case-0002/
...
wdqs-truthy/
case-0001/
export.rdf.nq
export.manifest.json
expected.rdf_hash.sha256
ci/
rdfc-gating.json
rdfc-gating-notes.md

````

### Fixture case contents (required)
Each `case-XXXX/` MUST include:

1. `export.rdf.nq`
   - The RDF dataset export for the declared projection
   - MUST be deterministic and sorted per the RDF export profile

2. `export.manifest.json`
   - MUST declare:
     - export profile id/version (e.g., `rdf-wdqs`, projection `full` or `truthy`)
     - integrity profile enabled (`rdf-integrity-rdfc`)
     - coverage boundaries (graphs included/excluded)
     - canonicalization algorithm id/version
     - resource limits used for canonicalization
     - any skolemization policy (if applicable)

3. `expected.rdf_hash.sha256`
   - A single line containing the expected SHA-256 hash hex string (64 hex chars)
   - Example:
     - `6f2a3b...<64 hex total>...91c0`

Optional additional files:
- `notes.md` (explain special modeling cases: blank nodes, datatypes, ranks)
- `expected.canonical.nq` (canonical output, if you choose to store it)

## Naming conventions
- `wdqs-full/` and `wdqs-truthy/` correspond to the RDF WDQS Export profile projections.
- `case-0001`, `case-0002`, ... MUST be stable identifiers.
- If a fixture changes in a way that affects semantics, create a new case id rather than overwriting.

## Coverage boundaries (mandatory)
Fixtures MUST explicitly record coverage boundaries because RDFC hashing is meaningful only relative to:

- which projection is covered (`full` vs `truthy`)
- which named graphs are included (assertion/reference/etc.)
- what is excluded (metadata graphs, timestamps, etc.)

A fixture without explicit coverage declaration is non-conformant to the integrity profile.

## Resource limits (mandatory)
Because dataset canonicalization has worst-case behavior, each fixture MUST record limits used when generating the expected hash, at minimum:

- `timeout_ms`
- `max_triples` (or size cap)
- `max_blank_nodes` (or equivalent)
- `max_memory_mb` (recommended)

If a fixture exceeds limits on a reference implementation:
- it should be moved to a “stress” category and not part of default CI gating.

## CI gating configuration (recommended)
`ci/rdfc-gating.json` SHOULD define:
- which RDFC test suite (and version) is used
- which subset is gated (test IDs)
- which fixture cases are included in CI
- the resource limits used in CI

Example (shape suggestion only):
```json
{
  "rdfc_suite": { "name": "W3C RDFC-1.0", "version": "1.0" },
  "gated_tests": ["t001", "t002", "t010"],
  "fixtures": [
    { "path": "fixtures/wdqs-full/case-0001", "projection": "full" },
    { "path": "fixtures/wdqs-truthy/case-0001", "projection": "truthy" }
  ],
  "limits": {
    "timeout_ms": 30000,
    "max_triples": 500000,
    "max_blank_nodes": 200000,
    "max_memory_mb": 1024
  }
}
````

## How implementers should use this directory

1. Generate an RDF export for a fixture case using `profile-rdf-wdqs-export`.
2. Apply `profile-rdf-integrity-rdfc` to produce canonical bytes and `rdf_hash`.
3. Compare to `expected.rdf_hash.sha256`.
4. Run the CI gate subset defined in `ci/rdfc-gating.json`.

## Open questions (to finalize)

* Whether to store `expected.canonical.nq` for debugging (larger repo, but faster diagnosis).
* Whether to vendor a minimal RDFC subset locally or require implementations to pull the suite externally.
* Whether to include additional projections (beyond full/truthy) in fixtures.

```
```

===== END 09-test-vectors/rdfc/README.md (#0036) =====

===== BEGIN 10-examples/claim-ir.example.json (#0037) =====
{
  "schema_version": "3.0",

  "document": {
    "doc_id": "doc:example:2026-01-07:001",
    "title": "Example source document for Claim-IR",
    "lang": "en",
    "source_url": "https://example.org/source/example-article",
    "retrieved_at": "2026-01-07T13:20:00Z",
    "published_at": "2026-01-05T09:00:00Z",
    "content_hash": { "alg": "sha256", "value": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" }
  },

  "extraction": {
    "run_id": "extract:run:001",
    "created_at": "2026-01-07T13:25:00Z",
    "producer": { "kind": "llm", "name": "ExampleExtractor", "version": "0.9.0" },
    "model": { "provider": "ExampleAI", "name": "example-model", "version": "2026-01" },
    "prompt_ref": { "prompt_id": "prompt:claim-ir:v3:en:001", "prompt_hash": "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb" },
    "notes": "Example extraction run; values include ambiguity and evidence pointers."
  },

  "subject": {
    "surface": "Ada Lovelace",
    "lang": "en",
    "candidates": [
      { "id": "Q7259", "score": 0.97, "label": "Ada Lovelace", "source": "alias_match" },
      { "id": "Q999999", "score": 0.12, "label": "Ada (disambiguation)", "source": "embedding_rank" }
    ]
  },

  "claims": [
    {
      "claim_id": "c:0001",
      "predicate": {
        "surface": "date of birth",
        "lang": "en",
        "candidates": [
          { "id": "P569", "score": 0.99, "label": "date of birth", "source": "exact_match" }
        ]
      },
      "object": {
        "kind": "time",
        "value": { "iso8601": "1815-12-10", "precision": "day", "calendar": "gregorian", "timezone": "UTC" }
      },
      "evidence": [
        {
          "source": {
            "source_url": "https://example.org/source/example-article",
            "title": "Example source document for Claim-IR",
            "retrieved_at": "2026-01-07T13:20:00Z"
          },
          "quote": "Ada Lovelace was born on 10 December 1815.",
          "page": 1,
          "offsets": { "start_char": 128, "end_char": 168 }
        }
      ],
      "confidence": 0.93,
      "uncertainty": { "confidence": 0.93, "method": "extractor_self_score", "notes": "High confidence; direct quote present." }
    },

    {
      "claim_id": "c:0002",
      "predicate": {
        "surface": "place of birth",
        "lang": "en",
        "candidates": [
          { "id": "P19", "score": 0.98, "label": "place of birth", "source": "alias_match" }
        ]
      },
      "object": {
        "kind": "item",
        "value": {
          "surface": "London",
          "lang": "en",
          "candidates": [
            { "id": "Q84", "score": 0.96, "label": "London", "source": "embedding_rank" },
            { "id": "Q92561", "score": 0.22, "label": "City of London", "source": "embedding_rank" }
          ]
        }
      },
      "evidence": [
        {
          "source": {
            "source_url": "https://example.org/source/example-article",
            "title": "Example source document for Claim-IR",
            "retrieved_at": "2026-01-07T13:20:00Z"
          },
          "quote": "She was born in London.",
          "page": 1,
          "offsets": { "start_char": 170, "end_char": 192 }
        }
      ],
      "confidence": 0.74,
      "uncertainty": {
        "confidence": 0.74,
        "method": "candidate_margin",
        "notes": "Ambiguity between London (Q84) and City of London (Q92561) remains explicit."
      }
    },

    {
      "claim_id": "c:0003",
      "predicate": {
        "surface": "occupation",
        "lang": "en",
        "candidates": [
          { "id": "P106", "score": 0.99, "label": "occupation", "source": "exact_match" }
        ]
      },
      "object": {
        "kind": "item",
        "value": {
          "surface": "mathematician",
          "lang": "en",
          "candidates": [
            { "id": "Q170790", "score": 0.88, "label": "mathematician", "source": "embedding_rank" },
            { "id": "Q1622272", "score": 0.31, "label": "scientist", "source": "embedding_rank" }
          ]
        }
      },
      "qualifiers": [
        {
          "predicate": {
            "surface": "start time",
            "lang": "en",
            "candidates": [{ "id": "P580", "score": 0.92, "label": "start time", "source": "alias_match" }]
          },
          "object": {
            "kind": "time",
            "value": { "iso8601": "1833-01-01", "precision": "year", "calendar": "gregorian", "timezone": "UTC" }
          }
        }
      ],
      "evidence": [
        {
          "source": {
            "source_url": "https://example.org/source/example-article",
            "title": "Example source document for Claim-IR",
            "retrieved_at": "2026-01-07T13:20:00Z"
          },
          "quote": "She was an English mathematician and writer.",
          "page": 1,
          "offsets": { "start_char": 10, "end_char": 55 }
        }
      ],
      "confidence": 0.67,
      "uncertainty": { "confidence": 0.67, "method": "weak_evidence", "notes": "Occupation inference; acceptable but should be reviewed." }
    }
  ],

  "warnings": [
    {
      "code": "AMBIGUOUS_SUBJECT",
      "message": "Subject has multiple plausible candidates; resolution required.",
      "path": "$.subject"
    },
    {
      "code": "VALUE_NORMALIZATION_NEEDED",
      "message": "Some values may require normalization during resolution (e.g., coordinate/time precision).",
      "path": "$.claims[2]"
    }
  ]
}

===== END 10-examples/claim-ir.example.json (#0037) =====

===== BEGIN 10-examples/exchange.example.json (#0038) =====
{
  "schema_version": "3.0",
  "artifact_type": "exchange",
  "exchange_version": "3.0",
  "created_at": "2026-01-07T16:10:00Z",

  "canonicalization_profile": "jcs-rfc8785",
  "canonicalization_version": "RFC8785",

  "kristal_id": "krs_9f3a0d6c7b0a1f2e3d4c5b6a7980a1b2c3d4e5f60718293a4b5c6d7e8f9a0b1c",
  "content_hash": {
    "algo": "sha256",
    "value": "9f3a0d6c7b0a1f2e3d4c5b6a7980a1b2c3d4e5f60718293a4b5c6d7e8f9a0b1c"
  },

  "build": {
    "build_id": "build-2026-01-07T161000Z-0007",
    "compiler_name": "kristal-compiler",
    "compiler_version": "3.0.0",
    "config_hash": "sha256:3c8a8fe8f10f4c4a44b8f4d4b6b1f8b7f1a9e9c5a2b1c0d9e8f7a6b5c4d3e2f1",
    "git_commit": "a1b2c3d4e5f6g7h8i9j0"
  },

  "inputs": {
    "source_snapshot_id": "snap-2026-01-06-wikipedia-dump-en",
    "recipe_id": "recipe-demo-encyclopedia-core",
    "claim_ir_ids": ["ci-2f5c2a9b-6c6d-4f9f-8caa-31c6a0b1b7d4"],
    "resolved_claim_ir_ids": ["rci-7a2f3df0-3e9b-4e63-9fd3-2f8b9a7d5d5c"],
    "previous_exchange_ids": []
  },

  "profiles_enabled": [
    "export-jsonld",
    "export-rdf-wdqs"
  ],

  "policies": {
    "ordering_policies": ["SPO", "POS"],
    "row_group_policy": { "type": "FIXED_ROWS", "rows": 100000 },
    "membership_filter_policy": {
      "family": "binary_fuse",
      "variant": "3wise",
      "key_space": "spo_hash",
      "target_fpr": 0.001,
      "bits_per_key": 9.5,
      "seed": 42
    },
    "bitmap_policy": { "format": "roaring", "run_opt": true },
    "join1_cap_policy": { "cap": 5000, "strict_mode": true, "on_exceed": "error" }
  },

  "evidence_index": [
    {
      "evidence_id": "ev-0001",
      "source_uri": "https://en.wikipedia.org/wiki/Douglas_Adams",
      "retrieved_at": "2026-01-06T09:12:43Z",
      "locator": { "type": "html_xpath", "value": "//*[@id='mw-content-text']" },
      "excerpt_sha256": "0b6d7cf44a2e2a8f8356a0a40c6b2d9b4e9d0f7d4c1b2a3f9e8d7c6b5a4f3e2d"
    },
    {
      "evidence_id": "ev-0002",
      "source_uri": "https://example.org/notes/travel-briefing.txt",
      "retrieved_at": "2026-01-06T10:00:00Z",
      "locator": { "type": "line_range", "value": "L10-L25" },
      "excerpt_sha256": "c9f5a2a9f3b2f1e0d9c8b7a6f5e4d3c2b1a0f9e8d7c6b5a4f3e2d1c0b9a8f7e6"
    }
  ],

  "exchange": {
    "items": [
      {
        "entity_id": "Q42",
        "type": "item",
        "labels": { "en": "Douglas Adams" },
        "descriptions": { "en": "English writer and humorist" },
        "aliases": { "en": ["Douglas Noel Adams"] },

        "statements": [
          {
            "statement_id": "st-Q42-P569-0001",
            "claim_id": "clm-0001",

            "property_id": "P569",
            "snaktype": "value",
            "datatype": "time",
            "datavalue": {
              "type": "time",
              "value": {
                "time": "+1952-03-11T00:00:00Z",
                "timezone": 0,
                "before": 0,
                "after": 0,
                "precision": 11,
                "calendarmodel": "http://www.wikidata.org/entity/Q1985727"
              }
            },

            "rank": "normal",

            "qualifiers": [],

            "references": [
              {
                "reference_id": "ref-0001",
                "evidence_ids": ["ev-0001"],
                "snaks": [
                  {
                    "property_id": "P854",
                    "snaktype": "value",
                    "datatype": "url",
                    "datavalue": {
                      "type": "string",
                      "value": "https://en.wikipedia.org/wiki/Douglas_Adams"
                    }
                  }
                ]
              }
            ]
          }
        ]
      },

      {
        "entity_id": "Q90",
        "type": "item",
        "labels": { "en": "Paris" },
        "descriptions": { "en": "capital and most populous city of France" },
        "aliases": { "en": [] },

        "statements": [
          {
            "statement_id": "st-Q90-P17-0001",
            "claim_id": "clm-0002",

            "property_id": "P17",
            "snaktype": "value",
            "datatype": "wikibase-item",
            "datavalue": {
              "type": "wikibase-entityid",
              "value": { "entity-type": "item", "numeric-id": 142, "id": "Q142" }
            },

            "rank": "normal",

            "qualifiers": [],

            "references": [
              {
                "reference_id": "ref-0002",
                "evidence_ids": ["ev-0002"],
                "snaks": [
                  {
                    "property_id": "P854",
                    "snaktype": "value",
                    "datatype": "url",
                    "datavalue": {
                      "type": "string",
                      "value": "https://example.org/notes/travel-briefing.txt"
                    }
                  }
                ]
              }
            ],

            "notes": [
              {
                "code": "SOURCE_LOW_AUTHORITY",
                "message": "Source is non-canonical; accepted under policy because claim is high-confidence and non-controversial."
              }
            ]
          }
        ]
      }
    ]
  },

  "signatures": [
    {
      "key_id": "kid-tenant_demo-2026-01",
      "alg": "ed25519",
      "signature": "base64url:U0lHTkFUVVJFX0VYQU1QTEVfTk9UX1JFQUw",
      "created_at": "2026-01-07T16:10:05Z",
      "signer": { "name": "Orgo Build Service", "org": "tenant_demo" }
    }
  ]
}

===== END 10-examples/exchange.example.json (#0038) =====

===== BEGIN 10-examples/resolved-claim-ir.example.json (#0039) =====
{
  "schema_version": "3.0",
  "artifact_type": "resolved-claim-ir",
  "artifact_id": "rci-7a2f3df0-3e9b-4e63-9fd3-2f8b9a7d5d5c",
  "created_at": "2026-01-07T15:20:00Z",

  "tenant_id": "tenant_demo",
  "build_id": "build-2026-01-07T152000Z-0001",

  "source": {
    "claim_ir_id": "ci-2f5c2a9b-6c6d-4f9f-8caa-31c6a0b1b7d4",
    "source_snapshot_id": "snap-2026-01-06-wikipedia-dump-en",
    "recipe_id": "recipe-demo-encyclopedia-core"
  },

  "resolver": {
    "name": "SenTient",
    "version": "0.9.0",
    "config_hash": "sha256:7d3d5b7a2b6f4d6d2c3fbb65d36d7b6c3a2f8f7f8c9a0b1c2d3e4f5a6b7c8d9e",
    "scoring_model": "funnel-v1",
    "max_candidates": 5,
    "preserve_ambiguity": true,
    "min_confidence_accept": 0.92
  },

  "evidence": [
    {
      "evidence_id": "ev-0001",
      "source_uri": "https://en.wikipedia.org/wiki/Douglas_Adams",
      "retrieved_at": "2026-01-06T09:12:43Z",
      "locator": { "type": "html_xpath", "value": "//*[@id='mw-content-text']" },
      "excerpt": "Douglas Noel Adams (11 March 1952 – 11 May 2001) was an English author...",
      "excerpt_sha256": "0b6d7cf44a2e2a8f8356a0a40c6b2d9b4e9d0f7d4c1b2a3f9e8d7c6b5a4f3e2d"
    },
    {
      "evidence_id": "ev-0002",
      "source_uri": "https://example.org/notes/travel-briefing.txt",
      "retrieved_at": "2026-01-06T10:00:00Z",
      "locator": { "type": "line_range", "value": "L10-L25" },
      "excerpt": "Paris is the capital of France. Paris has many museums.",
      "excerpt_sha256": "c9f5a2a9f3b2f1e0d9c8b7a6f5e4d3c2b1a0f9e8d7c6b5a4f3e2d1c0b9a8f7e6"
    }
  ],

  "resolved_claims": [
    {
      "claim_id": "clm-0001",
      "status": "resolved",
      "needs_human_review": false,

      "original": {
        "subject": { "surface": "Douglas Adams", "language": "en" },
        "predicate": { "surface": "date of birth", "language": "en" },
        "object": { "surface": "11 March 1952", "language": "en" },
        "confidence": 0.74,
        "evidence_ids": ["ev-0001"]
      },

      "resolution": {
        "subject": {
          "chosen": {
            "entity_id": "Q42",
            "label": "Douglas Adams",
            "match_type": "exact_alias",
            "confidence": 0.997
          },
          "candidates": [
            { "entity_id": "Q42", "label": "Douglas Adams", "confidence": 0.997 },
            { "entity_id": "Q214338", "label": "Douglas Adams (disambiguation)", "confidence": 0.031 }
          ]
        },

        "predicate": {
          "chosen": {
            "property_id": "P569",
            "label": "date of birth",
            "match_type": "label_match",
            "confidence": 0.995
          },
          "candidates": [
            { "property_id": "P569", "label": "date of birth", "confidence": 0.995 },
            { "property_id": "P570", "label": "date of death", "confidence": 0.072 }
          ]
        },

        "object": {
          "kind": "literal",
          "datatype": "xsd:date",
          "normalized": "1952-03-11",
          "confidence": 0.98,
          "normalization": {
            "steps": [
              { "op": "parse_date", "input": "11 March 1952", "output": "1952-03-11" },
              { "op": "type_assign", "datatype": "xsd:date" }
            ]
          }
        }
      },

      "notes": [
        {
          "code": "RESOLUTION_USED_CONTEXT",
          "message": "Used local context and evidence excerpt to disambiguate subject and property."
        }
      ]
    },

    {
      "claim_id": "clm-0002",
      "status": "ambiguous",
      "needs_human_review": true,

      "original": {
        "subject": { "surface": "Paris", "language": "en" },
        "predicate": { "surface": "country", "language": "en" },
        "object": { "surface": "France", "language": "en" },
        "confidence": 0.62,
        "evidence_ids": ["ev-0002"]
      },

      "resolution": {
        "subject": {
          "chosen": null,
          "candidates": [
            { "entity_id": "Q90", "label": "Paris", "confidence": 0.881 },
            { "entity_id": "Q207511", "label": "Paris (mythology)", "confidence": 0.211 },
            { "entity_id": "Q191", "label": "Paris, Texas", "confidence": 0.144 }
          ],
          "unresolved": {
            "reason": "SUBJECT_AMBIGUOUS",
            "message": "Multiple plausible entity matches for 'Paris' given limited context; preserving ambiguity."
          }
        },

        "predicate": {
          "chosen": {
            "property_id": "P17",
            "label": "country",
            "match_type": "label_match",
            "confidence": 0.991
          },
          "candidates": [
            { "property_id": "P17", "label": "country", "confidence": 0.991 }
          ]
        },

        "object": {
          "kind": "entity",
          "chosen": {
            "entity_id": "Q142",
            "label": "France",
            "match_type": "exact_alias",
            "confidence": 0.996
          },
          "candidates": [
            { "entity_id": "Q142", "label": "France", "confidence": 0.996 }
          ]
        }
      },

      "issues": [
        {
          "severity": "WARNING",
          "code": "SUBJECT_AMBIGUOUS",
          "message": "Subject entity could not be uniquely resolved; compilation may proceed only if policy allows unresolved subjects.",
          "location": {
            "claim_id": "clm-0002",
            "evidence_id": "ev-0002"
          }
        }
      ]
    }
  ],

  "summary": {
    "resolved_count": 1,
    "ambiguous_count": 1,
    "unresolved_count": 0,
    "error_count": 0,
    "warning_count": 1
  }
}

===== END 10-examples/resolved-claim-ir.example.json (#0039) =====

===== BEGIN 10-examples/runtime-pack-manifest.example.json (#0040) =====
{
  "manifest_version": "3.0.0",
  "runtime_pack_id": "2c6b4e3a6c52c9d2f4c6d5d25fb1b7c2dbcf7e4ef8b0e7d1b4e8b6f2a9c1d0ee",
  "created_at": "2026-01-07T12:34:56Z",
  "profiles": [
    "profile-query-tpf-pagination@1",
    "profile-jsonld-export@1"
  ],
  "exchange_ref": {
    "exchange_id": "9f3e6e5d2c1a4b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c",
    "exchange_manifest_hash": "0b1c2d3e4f5061728394a5b6c7d8e9f00112233445566778899aabbccddeeff0",
    "exchange_version": "exchange-2026-01-07"
  },
  "compiler": {
    "name": "kristal-compiler",
    "version": "3.0.0",
    "git_commit": "a1b2c3d4e5f6g7h8i9j0",
    "build_platform": "linux-x86_64"
  },
  "build": {
    "build_id": "f3a2c6f8-7dd4-4a5f-9b84-4a0a7b1d0d0d",
    "deterministic": true,
    "canonicalization_profile": "jcs-rfc8785@1",
    "config_hash": "7a1f9c2d3e4b5a6f708192a3b4c5d6e7f8091a2b3c4d5e6f708192a3b4c5d6e7"
  },
  "policies": {
    "data_ordering": {
      "policy": "qid_pid_statement_id_asc",
      "notes": "Sort primary triple store by subject(QID), predicate(PID), then stable statement_id."
    },
    "row_grouping": {
      "policy": "fixed_rows_1m",
      "notes": "Row groups are fixed at 1,000,000 rows."
    },
    "membership_filter": {
      "kind": "bloom",
      "seed": 42,
      "bits_per_key": 10,
      "hash_functions": 7,
      "notes": "Bloom filter for fast membership checks in offline devices."
    },
    "bitmap": {
      "format": "roaring_run_optimized",
      "run_optimize": true,
      "notes": "Roaring bitmaps with run optimization applied deterministically."
    },
    "parquet": {
      "compression": "zstd",
      "dictionary_encoding": true,
      "statistics": "rowgroup",
      "bloom_filters": {
        "enabled": false
      }
    }
  },
  "query_contract": {
    "contract_id": "kristal-query-core@1",
    "supports_pagination": true,
    "supports_cardinality_estimates": false
  },
  "files": [
    {
      "path": "data/triples.parquet",
      "role": "parquet_data",
      "sha256": "b0a4e6d88f4f7d34f9b3d8e0c1a2b3c4d5e6f708192a3b4c5d6e7f8091a2b3c4",
      "size_bytes": 987654321,
      "mime_type": "application/vnd.apache.parquet"
    },
    {
      "path": "index/spo.roaring",
      "role": "bitmap_index",
      "sha256": "c4b3a2f1e0d9c8b7a6f50918273645566778899aabbccddeeff00112233445566",
      "size_bytes": 123456789,
      "mime_type": "application/octet-stream"
    },
    {
      "path": "filters/membership.bloom",
      "role": "membership_filter",
      "sha256": "ddeeff00112233445566778899aabbccddeeff00112233445566778899aabbcc",
      "size_bytes": 543210,
      "mime_type": "application/octet-stream"
    },
    {
      "path": "query/capabilities.json",
      "role": "metadata",
      "sha256": "112233445566778899aabbccddeeff00112233445566778899aabbccddeeff00",
      "size_bytes": 2048,
      "mime_type": "application/json"
    },
    {
      "path": "exports/jsonld/exchange.jsonld",
      "role": "other",
      "sha256": "8899aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
      "size_bytes": 34567890,
      "mime_type": "application/ld+json"
    },
    {
      "path": "runtime-pack-manifest.json",
      "role": "metadata",
      "sha256": "0f0e0d0c0b0a09080706050403020100ffeeddccbbaa99887766554433221100",
      "size_bytes": 8192,
      "mime_type": "application/json"
    }
  ],
  "integrity": {
    "hash_alg": "sha256",
    "manifest_sha256": "0f0e0d0c0b0a09080706050403020100ffeeddccbbaa99887766554433221100",
    "pack_sha256": "aa55aa55aa55aa55aa55aa55aa55aa55aa55aa55aa55aa55aa55aa55aa55aa55"
  },
  "signatures": [
    {
      "key_id": "tenant_123_root_ed25519_v1",
      "alg": "ed25519",
      "signature": "MEUCIQDYf3sYwqU5r7pD3dB9q8o2mTg1b2dQdGm0dXk7xwIgN5v7yQw4z3Q0+g8xR9pW1w3GqVq+v3n2fY0aQn8=",
      "created_at": "2026-01-07T12:35:10Z"
    }
  ]
}

===== END 10-examples/runtime-pack-manifest.example.json (#0040) =====

===== BEGIN 10-examples/validation-report.example.json (#0041) =====
{
  "schema_version": "kristal.v3.validation-report@1.0",
  "report_id": "vrpt_example_0001",
  "generated_at": "2026-01-07T00:00:00Z",
  "build_id": "build_example_0001",
  "tenant_id": "tenant_example",
  "input_refs": {
    "claim_ir_batch_ref": "sha256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "resolved_claim_ir_batch_ref": "sha256:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
  },
  "status": "FAIL",
  "summary": {
    "errors": 2,
    "warnings": 2,
    "infos": 1
  },
  "results": [
    {
      "severity": "ERROR",
      "code": "VAL.ENTITY.UNRESOLVED",
      "message": "Entity surface could not be resolved to a unique QID and the rule requires a unique binding.",
      "claim_id": "claim_00042",
      "path": "/claims/42/subject",
      "details": {
        "surface": "Springfield",
        "resolution_state": "RESOLVED_MULTI",
        "top_candidates": [
          { "id": "Q18094", "score": 0.63 },
          { "id": "Q23055", "score": 0.61 },
          { "id": "Q45761", "score": 0.59 }
        ],
        "required": "RESOLVED_SINGLE"
      }
    },
    {
      "severity": "ERROR",
      "code": "VAL.EVIDENCE.MISSING",
      "message": "Claim requires at least one evidence pointer, but none were provided.",
      "claim_id": "claim_00077",
      "path": "/claims/77/evidence",
      "details": {
        "min_evidence": 1,
        "provided_evidence": 0
      }
    },
    {
      "severity": "WARNING",
      "code": "VAL.LITERAL.NORMALIZATION.LOSSY",
      "message": "Quantity normalization required unit coercion; precision may be reduced.",
      "claim_id": "claim_00103",
      "path": "/claims/103/value",
      "details": {
        "original": { "raw": "3.2 tons", "unit": "ton" },
        "normalized": { "value": 3200, "unit": "kg", "precision": "approx" },
        "lossy": true
      }
    },
    {
      "severity": "WARNING",
      "code": "VAL.POLICY.NON_PORTABLE",
      "message": "Runtime policy selection is not in the v3 portable policy set; pack will not be comparable across implementations.",
      "path": "/runtime_pack/policy_selections/ordering",
      "details": {
        "provided": "CUSTOM_ORDERING_XYZ",
        "allowed": ["SPO", "SOP", "PSO", "POS", "OSP", "OPS", "ORDER_SET([...])"]
      }
    },
    {
      "severity": "INFO",
      "code": "VAL.EXPORT.RDF_INTEGRITY.DISABLED",
      "message": "RDF integrity profile (RDFC) is not enabled; rdf_hash was not computed.",
      "details": {
        "profile": "export-integrity-rdfc",
        "enabled": false
      }
    }
  ],
  "policy_context": {
    "policy_selections_version": "v3.0",
    "ordering": "ORDER_SET([\"SPO\"])",
    "row_groups": "FIXED_ROWS(500000)",
    "membership_filters": {
      "family": "BINARY_FUSE",
      "variant": "4_WISE",
      "seed": 1337,
      "bits_per_key": 9.5,
      "target_false_positive_rate": 0.01,
      "key_spaces": ["SPO_KEY"]
    },
    "bitmaps": {
      "format": "ROARING",
      "run_optimization": "ENABLED"
    },
    "query_limits": {
      "join1_cap": { "default": 100000, "mode": "STRICT" },
      "paging": "CURSOR"
    }
  },
  "integrity": {
    "report_hash": "sha256:cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc",
    "canonicalization_profile": "jcs-rfc8785",
    "canonicalization_version": "1.0",
    "signatures": [
      {
        "key_id": "ed25519:example_key_01",
        "algorithm": "ed25519",
        "signature": "base64:ZmFrZV9zaWduYXR1cmU=",
        "signed_at": "2026-01-07T00:00:00Z"
      }
    ]
  }
}

===== END 10-examples/validation-report.example.json (#0041) =====

===== BEGIN README.md (#0042) =====
# Kristal v3 Documentation

This repository contains the v3 documentation set for **Kristal**: the portable, verifiable, offline-executable unit of encyclopedic knowledge (Exchange + Runtime Pack), designed to be Wikidata/Wikibase-aligned and reproducible across toolchains.

## How to use this repo

Start here:
1) `00-overview/vision-and-scope.md`
2) `00-overview/v2-to-v3-summary.md`
3) `01-core-spec/kristal-v3-core-spec.md`

If you are implementing:
- IDs / hashing / signing → `01-core-spec/ids-canonicalization-hashing.md`, `01-core-spec/signatures-trust.md`
- Schemas → `02-schemas/`
- Pack reproducibility → `03-reproducibility/`
- Offline query surface → `04-query/query-contract.md`
- Optional features → `05-profiles/`
- Ecosystem integration (Orgo/SenTient/Architect/Konnaxion) → `06-integration/`
- Security and multi-tenancy → `07-security/`
- Ops guidance (non-normative patterns) → `08-ops/`

## Repository structure

- `00-overview/`  
  High-level scope, non-goals, and the v2 → v3 delta summary.

- `01-core-spec/`  
  **Normative core**. Keep surface area small. Strong defaults. Everything else is via profiles.

- `02-schemas/`  
  **Normative JSON Schemas** for Claim-IR, Resolved Claim-IR, Validation Report, Exchange Manifest, Runtime Pack Manifest.

- `03-reproducibility/`  
  Deterministic compilation rules and **allowed policies** (enumerated ordering/row-group/filter policies) plus acceptance tests.

- `04-query/`  
  Offline query contract (constrained semantics; optional TPF-like pagination profile).

- `05-profiles/`  
  Optional standardized profiles (JSON-LD export, RDF/WDQS export, RDFC integrity, nanopub/PROV-O, SHACL, ShEx, query pagination).

- `06-integration/`  
  Inter-system contracts for **Orgo × SenTient × Architect × Konnaxion**.

- `07-security/`  
  Trust roots, signature verification, downgrade/rollback policy, multi-tenancy boundaries.

- `08-ops/`  
  Non-normative operational guidance using “senior architecture patterns” framing (failure paths, correlation IDs, canary/blue-green).

- `09-test-vectors/`  
  Golden vectors for canonicalization/hashing and (optional) RDF integrity fixtures.

- `10-examples/`  
  Worked examples for implementers.

## Conformance model

### v3 Core (required)
Implementations claiming **Kristal v3 core** conformance MUST:
- Use **RFC 8785 (JCS)** for canonical JSON used in hashing.
- Define **exact hashed material** (including exclusions such as signatures) and implement it identically.
- Enforce **fail-closed** behavior when hashes/signatures are declared but do not verify.
- Produce **reproducible Exchange/Runtime artifacts**: manifests record all build-affecting policies/parameters.
- Pass the **core test vectors** in `09-test-vectors/`.

### Profiles (optional)
Advanced features are expressed as explicit profiles in `05-profiles/`. Implementations MAY claim profile conformance individually (e.g., RDF Integrity (RDFC), nanopub/PROV-O, SHACL, ShEx, TPF-like pagination).

## Ecosystem placement (summary)
- **Claim-IR**: the only direct extractor output (strict schema; uncertainty + evidence).
- **SenTient**: resolution contract (ranked QID/PID candidates; preserve unresolved ambiguity).
- **Validation**: deterministic acceptance gate (“no compile on fail”).
- **Kristal Exchange**: canonical, content-addressed source of truth.
- **Runtime Pack**: derived offline-executable index (no SPARQL; constrained query model).
- **Architect**: deterministic renderer after validation; must trace outputs to claim/evidence.
- **Orgo**: operational control plane (workflow, auditing, distribution status).
- **Konnaxion**: distribution + offline UX (signed packs, caching, rollback rules).

## Editing rules for this repo

- Normative language uses **MUST / SHOULD / MAY**.
- Each profile doc must clearly state:
  - requirements,
  - what is hashed (if relevant),
  - limits (timeouts/resource bounds where needed),
  - conformance tests and fixtures.

- Keep the **core small**; push tunability into profiles or non-normative guidance.

## Versioning
- This repo documents **Kristal v3**. v2 compatibility notes belong in `00-overview/v2-to-v3-summary.md`.
- Any change that affects hashes/IDs or deterministic build outputs requires:
  - updated test vectors in `09-test-vectors/`,
  - explicit version bump in the relevant canonicalization/profile identifiers.

===== END README.md (#0042) =====
