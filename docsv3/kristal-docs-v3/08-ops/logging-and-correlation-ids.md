````md
# Logging and correlation IDs (non-normative)

## Status
Non-normative operational guidance (Kristal v3)

## Purpose

This document defines a consistent logging and correlation-ID practice for the Kristal build and distribution ecosystem (Orgo × SenTient × Architect × Konnaxion). The goal is to:
- make failures diagnosable quickly
- support reliable audit and provenance workflows
- enable end-to-end tracing across pipeline stages
- preserve multi-tenant isolation while retaining debuggability

These practices are **not** embedded as first-class objects in Kristal Exchange/Runtime schemas. They are operational conventions used by build/distribution systems and referenced in logs, metrics, and Orgo audit records.

## Principles

- Use **structured logs** (JSON) with stable field names.
- Generate correlation IDs at the **earliest** boundary (Orgo admission).
- Propagate IDs across service boundaries (HTTP headers, message metadata, job context).
- Avoid PII in logs; log hashes/pointers instead.
- Prefer immutable identifiers (content-addressed IDs) for durable linkage.

## Core identifiers

### 1) `build_id` (required)
**Scope:** One end-to-end Kristal build workflow execution.  
**Generated by:** Orgo (workflow/orchestrator).  
**Format:** UUIDv4 (recommended) or equivalent unique opaque string.  
**Stability:** Constant across all stages and retries.

Used for:
- tracing ingestion → extraction → resolution → validation → publish → distribution
- grouping all logs/metrics for a single build run

### 2) `tenant_id` (required in multi-tenant deployments)
**Scope:** Tenant or namespace boundary for admission control and isolation.  
**Generated by:** Orgo / identity layer.  
**Format:** stable opaque ID.

### 3) Content-addressed IDs (required where applicable)

#### `exchange_id`
Content-addressed identifier for the finalized Kristal Exchange artifact.

#### `runtime_pack_id`
Content-addressed identifier for the Runtime Pack artifact derived from Exchange.

#### `kristal_id` (if used as the canonical “unit id” in your system)
If you use `kristal_id` as a top-level unit ID distinct from `exchange_id`, it should be logged consistently as well.

### 4) Claim-level IDs

#### `claim_id` (required when operating at claim granularity)
Stable identifier for a Claim-IR/Exchange claim.  
Used to trace:
- extractor outputs → resolution outcomes → validation results → Exchange statements → Architect render outputs

#### `statement_id` (optional, if you differentiate statements from claims)
If a claim expands into multiple normalized statements, log `statement_id` to disambiguate.

### 5) Input references

#### `input_ref` (recommended)
A hash/pointer for the original input unit (document, email archive, PDF blob, dataset chunk).  
Prefer:
- content hash (sha256) of the raw blob
- or stable URI hash if raw cannot be logged

Avoid logging raw URLs or file paths if they can leak PII.

### 6) Resolution references

#### `surface_id` / `mention_id` (optional)
If SenTient processes many surfaces/mentions, log a stable ID per mention to isolate failures.

#### `candidate_id` (optional)
If SenTient returns ranked candidate QIDs/PIDs, log the chosen candidate ID when selection is made (and log ambiguity when selection is not made).

## Propagation rules

### Orgo → workers/services
- Orgo MUST attach `build_id` and `tenant_id` to:
  - queue messages
  - job metadata
  - API requests to SenTient/Architect/compiler

### Service-to-service (HTTP) propagation (recommended)
Use headers:
- `X-Build-Id: <build_id>`
- `X-Tenant-Id: <tenant_id>`
- `X-Trace-Id: <trace_id>` (if using distributed tracing)
- `X-Parent-Span-Id: <span_id>` (if applicable)

### Message queue propagation (recommended)
Attach IDs as message metadata fields:
- `build_id`, `tenant_id`, `stage`, `attempt`

## Structured log fields (recommended minimum set)

All services SHOULD emit logs with the following fields where applicable:

Final recommended minimum fields:
- `ts` (RFC 3339 timestamp)
- `level` (`DEBUG|INFO|WARN|ERROR`)
- `service` (`orgo|sentient|kristal-compiler|architect|konnaxion|...`)
- `stage` (`ingest|extract|resolve|validate|exchange_finalize|pack_compile|distribute|render`)
- `event` (short stable string, e.g., `STAGE_START`, `VALIDATION_FAILED`)
- `build_id`
- `tenant_id` (if multi-tenant)
- `exchange_id` (once known)
- `runtime_pack_id` (once known)
- `claim_id` (when applicable)
- `input_ref` (when applicable)
- `attempt` (retry number)
- `duration_ms` (for completion events)
- `error_code` and `error_message` (bounded) for failures

## Event taxonomy (recommended)

### Stage lifecycle
- `STAGE_START`
- `STAGE_END`
- `STAGE_RETRY`
- `STAGE_CANCELLED`

### Resolution (SenTient)
- `RESOLVE_REQUEST`
- `RESOLVE_TIMEOUT`
- `RESOLVE_CIRCUIT_OPEN`
- `RESOLVE_UNRESOLVED_PRESERVED`

### Validation
- `VALIDATION_START`
- `VALIDATION_FAILED`
- `VALIDATION_TIMEOUT`

### Exchange / Pack
- `EXCHANGE_FINALIZE_START`
- `EXCHANGE_FINALIZE_SUCCESS`
- `PACK_COMPILE_START`
- `PACK_COMPILE_SUCCESS`

### Integrity and verification
- `SIGNATURE_VERIFY_FAILED`
- `HASH_MISMATCH`
- `FAIL_CLOSED_TRIGGERED`

### Distribution (Konnaxion)
- `PACK_PUBLISH_START`
- `PACK_PUBLISH_SUCCESS`
- `PACK_ROLLOUT_CANARY_START`
- `PACK_ROLLOUT_CANARY_FAIL`
- `PACK_ROLLBACK`

### DLQ / quarantine
- `DLQ_ENQUEUE`
- `DLQ_TRIAGE_DECISION`

## Recommended linkage in artifacts (non-normative)

Do not embed operational meta-structures into Exchange/Pack schemas as first-class objects. However:
- `build.build_id` is already captured in the Runtime Pack Manifest (core requirement).
- Exchange manifests may record a `build_id` for traceability, if desired.
- Validation reports should include `build_id` and `claim_id` fields so validation failures can be traced precisely.

## Privacy and security guidance

- Do not log raw extracted text unless explicitly required and protected.
- Prefer hashed references to evidence blobs and documents.
- Avoid logging full signatures or private key material.
- For public logs, redact or hash `tenant_id` if it could be sensitive.

## Examples (non-normative)

### Stage start log
```json
{
  "ts": "2026-01-07T14:10:12Z",
  "level": "INFO",
  "service": "kristal-compiler",
  "stage": "validate",
  "event": "STAGE_START",
  "build_id": "f3a2c6f8-7dd4-4a5f-9b84-4a0a7b1d0d0d",
  "tenant_id": "tenant_123",
  "input_ref": "sha256:9b3c...e21a",
  "attempt": 1
}
````

### Validation failure log

```json
{
  "ts": "2026-01-07T14:10:44Z",
  "level": "ERROR",
  "service": "kristal-compiler",
  "stage": "validate",
  "event": "VALIDATION_FAILED",
  "build_id": "f3a2c6f8-7dd4-4a5f-9b84-4a0a7b1d0d0d",
  "tenant_id": "tenant_123",
  "claim_id": "claim_7f2b...",
  "error_code": "VALIDATION_FAILED",
  "error_message": "P31 value type mismatch",
  "duration_ms": 32150
}
```

## Appendix: recommended dashboards (guidance)

* Build success rate by stage and tenant
* Median/p95 stage duration
* SenTient timeout rate + circuit breaker opens
* Validation failure reasons top-N
* Pack publish success + rollback events
* DLQ depth and age

```
```
